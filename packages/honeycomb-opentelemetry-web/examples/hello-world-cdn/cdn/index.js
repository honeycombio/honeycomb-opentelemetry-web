var HNY = (function (exports) {
    'use strict';

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Updates to this file should also be replicated to @opentelemetry/core too.
    /**
     * - globalThis (New standard)
     * - self (Will return the current window instance for supported browsers)
     * - window (fallback for older browser implementations)
     * - global (NodeJS implementation)
     * - <object> (When all else fails)
     */
    /** only globals that common to node and browsers are allowed */
    // eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
    var _globalThis$2 = typeof globalThis === 'object' ? globalThis : typeof self === 'object' ? self : typeof window === 'object' ? window : typeof global === 'object' ? global : {};

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // this is autogenerated file, see scripts/version-update.js
    var VERSION$3 = '1.9.0';

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    /**
     * Create a function to test an API version to see if it is compatible with the provided ownVersion.
     *
     * The returned function has the following semantics:
     * - Exact match is always compatible
     * - Major versions must match exactly
     *    - 1.x package cannot use global 2.x package
     *    - 2.x package cannot use global 1.x package
     * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
     *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
     *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
     * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
     * - Patch and build tag differences are not considered at this time
     *
     * @param ownVersion version which should be checked against
     */
    function _makeCompatibilityCheck(ownVersion) {
      var acceptedVersions = new Set([ownVersion]);
      var rejectedVersions = new Set();
      var myVersionMatch = ownVersion.match(re);
      if (!myVersionMatch) {
        // we cannot guarantee compatibility so we always return noop
        return function () {
          return false;
        };
      }
      var ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4]
      };
      // if ownVersion has a prerelease tag, versions must match exactly
      if (ownVersionParsed.prerelease != null) {
        return function isExactmatch(globalVersion) {
          return globalVersion === ownVersion;
        };
      }
      function _reject(v) {
        rejectedVersions.add(v);
        return false;
      }
      function _accept(v) {
        acceptedVersions.add(v);
        return true;
      }
      return function isCompatible(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
          return true;
        }
        if (rejectedVersions.has(globalVersion)) {
          return false;
        }
        var globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch) {
          // cannot parse other version
          // we cannot guarantee compatibility so we always noop
          return _reject(globalVersion);
        }
        var globalVersionParsed = {
          major: +globalVersionMatch[1],
          minor: +globalVersionMatch[2],
          patch: +globalVersionMatch[3],
          prerelease: globalVersionMatch[4]
        };
        // if globalVersion has a prerelease tag, versions must match exactly
        if (globalVersionParsed.prerelease != null) {
          return _reject(globalVersion);
        }
        // major versions must match
        if (ownVersionParsed.major !== globalVersionParsed.major) {
          return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
          if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
            return _accept(globalVersion);
          }
          return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      };
    }
    /**
     * Test an API version to see if it is compatible with this API.
     *
     * - Exact match is always compatible
     * - Major versions must match exactly
     *    - 1.x package cannot use global 2.x package
     *    - 2.x package cannot use global 1.x package
     * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
     *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
     *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
     * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
     * - Patch and build tag differences are not considered at this time
     *
     * @param version version of the API requesting an instance of the global API
     */
    var isCompatible = _makeCompatibilityCheck(VERSION$3);

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var major = VERSION$3.split('.')[0];
    var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
    var _global$1 = _globalThis$2;
    function registerGlobal(type, instance, diag, allowOverride) {
      var _a;
      if (allowOverride === void 0) {
        allowOverride = false;
      }
      var api = _global$1[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global$1[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
        version: VERSION$3
      };
      if (!allowOverride && api[type]) {
        // already registered an API of this type
        var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
        diag.error(err.stack || err.message);
        return false;
      }
      if (api.version !== VERSION$3) {
        // All registered APIs must be of the same version exactly
        var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION$3);
        diag.error(err.stack || err.message);
        return false;
      }
      api[type] = instance;
      diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION$3 + ".");
      return true;
    }
    function getGlobal(type) {
      var _a, _b;
      var globalVersion = (_a = _global$1[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
      if (!globalVersion || !isCompatible(globalVersion)) {
        return;
      }
      return (_b = _global$1[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
    }
    function unregisterGlobal(type, diag) {
      diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION$3 + ".");
      var api = _global$1[GLOBAL_OPENTELEMETRY_API_KEY];
      if (api) {
        delete api[type];
      }
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __read$e = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray$6 = undefined && undefined.__spreadArray || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    /**
     * Component Logger which is meant to be used as part of any component which
     * will add automatically additional namespace in front of the log message.
     * It will then forward all message to global diag logger
     * @example
     * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });
     * cLogger.debug('test');
     * // @opentelemetry/instrumentation-http test
     */
    var DiagComponentLogger = /** @class */function () {
      function DiagComponentLogger(props) {
        this._namespace = props.namespace || 'DiagComponentLogger';
      }
      DiagComponentLogger.prototype.debug = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy('debug', this._namespace, args);
      };
      DiagComponentLogger.prototype.error = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy('error', this._namespace, args);
      };
      DiagComponentLogger.prototype.info = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy('info', this._namespace, args);
      };
      DiagComponentLogger.prototype.warn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy('warn', this._namespace, args);
      };
      DiagComponentLogger.prototype.verbose = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy('verbose', this._namespace, args);
      };
      return DiagComponentLogger;
    }();
    function logProxy(funcName, namespace, args) {
      var logger = getGlobal('diag');
      // shortcut if logger not set
      if (!logger) {
        return;
      }
      args.unshift(namespace);
      return logger[funcName].apply(logger, __spreadArray$6([], __read$e(args), false));
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Defines the available internal logging levels for the diagnostic logger, the numeric values
     * of the levels are defined to match the original values from the initial LogLevel to avoid
     * compatibility/migration issues for any implementation that assume the numeric ordering.
     */
    var DiagLogLevel;
    (function (DiagLogLevel) {
      /** Diagnostic Logging level setting to disable all logging (except and forced logs) */
      DiagLogLevel[DiagLogLevel["NONE"] = 0] = "NONE";
      /** Identifies an error scenario */
      DiagLogLevel[DiagLogLevel["ERROR"] = 30] = "ERROR";
      /** Identifies a warning scenario */
      DiagLogLevel[DiagLogLevel["WARN"] = 50] = "WARN";
      /** General informational log message */
      DiagLogLevel[DiagLogLevel["INFO"] = 60] = "INFO";
      /** General debug log message */
      DiagLogLevel[DiagLogLevel["DEBUG"] = 70] = "DEBUG";
      /**
       * Detailed trace level logging should only be used for development, should only be set
       * in a development environment.
       */
      DiagLogLevel[DiagLogLevel["VERBOSE"] = 80] = "VERBOSE";
      /** Used to set the logging level to include all logging */
      DiagLogLevel[DiagLogLevel["ALL"] = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function createLogLevelDiagLogger(maxLevel, logger) {
      if (maxLevel < DiagLogLevel.NONE) {
        maxLevel = DiagLogLevel.NONE;
      } else if (maxLevel > DiagLogLevel.ALL) {
        maxLevel = DiagLogLevel.ALL;
      }
      // In case the logger is null or undefined
      logger = logger || {};
      function _filterFunc(funcName, theLevel) {
        var theFunc = logger[funcName];
        if (typeof theFunc === 'function' && maxLevel >= theLevel) {
          return theFunc.bind(logger);
        }
        return function () {};
      }
      return {
        error: _filterFunc('error', DiagLogLevel.ERROR),
        warn: _filterFunc('warn', DiagLogLevel.WARN),
        info: _filterFunc('info', DiagLogLevel.INFO),
        debug: _filterFunc('debug', DiagLogLevel.DEBUG),
        verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE)
      };
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __read$d = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray$5 = undefined && undefined.__spreadArray || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var API_NAME$4 = 'diag';
    /**
     * Singleton object which represents the entry point to the OpenTelemetry internal
     * diagnostic API
     */
    var DiagAPI = /** @class */function () {
      /**
       * Private internal constructor
       * @private
       */
      function DiagAPI() {
        function _logProxy(funcName) {
          return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var logger = getGlobal('diag');
            // shortcut if logger not set
            if (!logger) return;
            return logger[funcName].apply(logger, __spreadArray$5([], __read$d(args), false));
          };
        }
        // Using self local variable for minification purposes as 'this' cannot be minified
        var self = this;
        // DiagAPI specific functions
        var setLogger = function (logger, optionsOrLogLevel) {
          var _a, _b, _c;
          if (optionsOrLogLevel === void 0) {
            optionsOrLogLevel = {
              logLevel: DiagLogLevel.INFO
            };
          }
          if (logger === self) {
            // There isn't much we can do here.
            // Logging to the console might break the user application.
            // Try to log to self. If a logger was previously registered it will receive the log.
            var err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');
            self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === 'number') {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          var oldLogger = getGlobal('diag');
          var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger);
          // There already is an logger registered. We'll let it know before overwriting it.
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : '<failed to generate stacktrace>';
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal('diag', newLogger, self, true);
        };
        self.setLogger = setLogger;
        self.disable = function () {
          unregisterGlobal(API_NAME$4, self);
        };
        self.createComponentLogger = function (options) {
          return new DiagComponentLogger(options);
        };
        self.verbose = _logProxy('verbose');
        self.debug = _logProxy('debug');
        self.info = _logProxy('info');
        self.warn = _logProxy('warn');
        self.error = _logProxy('error');
      }
      /** Get the singleton instance of the DiagAPI API */
      DiagAPI.instance = function () {
        if (!this._instance) {
          this._instance = new DiagAPI();
        }
        return this._instance;
      };
      return DiagAPI;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __read$c = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __values$5 = undefined && undefined.__values || function (o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function () {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var BaggageImpl = /** @class */function () {
      function BaggageImpl(entries) {
        this._entries = entries ? new Map(entries) : new Map();
      }
      BaggageImpl.prototype.getEntry = function (key) {
        var entry = this._entries.get(key);
        if (!entry) {
          return undefined;
        }
        return Object.assign({}, entry);
      };
      BaggageImpl.prototype.getAllEntries = function () {
        return Array.from(this._entries.entries()).map(function (_a) {
          var _b = __read$c(_a, 2),
            k = _b[0],
            v = _b[1];
          return [k, v];
        });
      };
      BaggageImpl.prototype.setEntry = function (key, entry) {
        var newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      };
      BaggageImpl.prototype.removeEntry = function (key) {
        var newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      };
      BaggageImpl.prototype.removeEntries = function () {
        var e_1, _a;
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl(this._entries);
        try {
          for (var keys_1 = __values$5(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            newBaggage._entries.delete(key);
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return newBaggage;
      };
      BaggageImpl.prototype.clear = function () {
        return new BaggageImpl();
      };
      return BaggageImpl;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Symbol used to make BaggageEntryMetadata an opaque type
     */
    var baggageEntryMetadataSymbol = Symbol('BaggageEntryMetadata');

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var diag$1 = DiagAPI.instance();
    /**
     * Create a new Baggage with optional entries
     *
     * @param entries An array of baggage entries the new baggage should contain
     */
    function createBaggage(entries) {
      if (entries === void 0) {
        entries = {};
      }
      return new BaggageImpl(new Map(Object.entries(entries)));
    }
    /**
     * Create a serializable BaggageEntryMetadata object from a string.
     *
     * @param str string metadata. Format is currently not defined by the spec and has no special meaning.
     *
     */
    function baggageEntryMetadataFromString(str) {
      if (typeof str !== 'string') {
        diag$1.error("Cannot create baggage metadata from unknown type: " + typeof str);
        str = '';
      }
      return {
        __TYPE__: baggageEntryMetadataSymbol,
        toString: function () {
          return str;
        }
      };
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /** Get a key to uniquely identify a context value */
    function createContextKey(description) {
      // The specification states that for the same input, multiple calls should
      // return different keys. Due to the nature of the JS dependency management
      // system, this creates problems where multiple versions of some package
      // could hold different keys for the same property.
      //
      // Therefore, we use Symbol.for which returns the same key for the same input.
      return Symbol.for(description);
    }
    var BaseContext = /** @class */function () {
      /**
       * Construct a new context which inherits values from an optional parent context.
       *
       * @param parentContext a context from which to inherit values
       */
      function BaseContext(parentContext) {
        // for minification
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : new Map();
        self.getValue = function (key) {
          return self._currentContext.get(key);
        };
        self.setValue = function (key, value) {
          var context = new BaseContext(self._currentContext);
          context._currentContext.set(key, value);
          return context;
        };
        self.deleteValue = function (key) {
          var context = new BaseContext(self._currentContext);
          context._currentContext.delete(key);
          return context;
        };
      }
      return BaseContext;
    }();
    /** The root context is used as the default parent context when there is no active context */
    var ROOT_CONTEXT = new BaseContext();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var consoleMap = [{
      n: 'error',
      c: 'error'
    }, {
      n: 'warn',
      c: 'warn'
    }, {
      n: 'info',
      c: 'info'
    }, {
      n: 'debug',
      c: 'debug'
    }, {
      n: 'verbose',
      c: 'trace'
    }];
    /**
     * A simple Immutable Console based diagnostic logger which will output any messages to the Console.
     * If you want to limit the amount of logging to a specific level or lower use the
     * {@link createLogLevelDiagLogger}
     */
    var DiagConsoleLogger = /** @class */function () {
      function DiagConsoleLogger() {
        function _consoleFunc(funcName) {
          return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (console) {
              // Some environments only expose the console when the F12 developer console is open
              // eslint-disable-next-line no-console
              var theFunc = console[funcName];
              if (typeof theFunc !== 'function') {
                // Not all environments support all functions
                // eslint-disable-next-line no-console
                theFunc = console.log;
              }
              // One last final check
              if (typeof theFunc === 'function') {
                return theFunc.apply(console, args);
              }
            }
          };
        }
        for (var i = 0; i < consoleMap.length; i++) {
          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
        }
      }
      return DiagConsoleLogger;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __extends$5 = undefined && undefined.__extends || function () {
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    /**
     * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses
     * constant NoopMetrics for all of its methods.
     */
    var NoopMeter = /** @class */function () {
      function NoopMeter() {}
      /**
       * @see {@link Meter.createGauge}
       */
      NoopMeter.prototype.createGauge = function (_name, _options) {
        return NOOP_GAUGE_METRIC;
      };
      /**
       * @see {@link Meter.createHistogram}
       */
      NoopMeter.prototype.createHistogram = function (_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
      };
      /**
       * @see {@link Meter.createCounter}
       */
      NoopMeter.prototype.createCounter = function (_name, _options) {
        return NOOP_COUNTER_METRIC;
      };
      /**
       * @see {@link Meter.createUpDownCounter}
       */
      NoopMeter.prototype.createUpDownCounter = function (_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
      };
      /**
       * @see {@link Meter.createObservableGauge}
       */
      NoopMeter.prototype.createObservableGauge = function (_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
      };
      /**
       * @see {@link Meter.createObservableCounter}
       */
      NoopMeter.prototype.createObservableCounter = function (_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
      };
      /**
       * @see {@link Meter.createObservableUpDownCounter}
       */
      NoopMeter.prototype.createObservableUpDownCounter = function (_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      };
      /**
       * @see {@link Meter.addBatchObservableCallback}
       */
      NoopMeter.prototype.addBatchObservableCallback = function (_callback, _observables) {};
      /**
       * @see {@link Meter.removeBatchObservableCallback}
       */
      NoopMeter.prototype.removeBatchObservableCallback = function (_callback) {};
      return NoopMeter;
    }();
    var NoopMetric = /** @class */function () {
      function NoopMetric() {}
      return NoopMetric;
    }();
    var NoopCounterMetric = /** @class */function (_super) {
      __extends$5(NoopCounterMetric, _super);
      function NoopCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopCounterMetric.prototype.add = function (_value, _attributes) {};
      return NoopCounterMetric;
    }(NoopMetric);
    var NoopUpDownCounterMetric = /** @class */function (_super) {
      __extends$5(NoopUpDownCounterMetric, _super);
      function NoopUpDownCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopUpDownCounterMetric.prototype.add = function (_value, _attributes) {};
      return NoopUpDownCounterMetric;
    }(NoopMetric);
    var NoopGaugeMetric = /** @class */function (_super) {
      __extends$5(NoopGaugeMetric, _super);
      function NoopGaugeMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopGaugeMetric.prototype.record = function (_value, _attributes) {};
      return NoopGaugeMetric;
    }(NoopMetric);
    var NoopHistogramMetric = /** @class */function (_super) {
      __extends$5(NoopHistogramMetric, _super);
      function NoopHistogramMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopHistogramMetric.prototype.record = function (_value, _attributes) {};
      return NoopHistogramMetric;
    }(NoopMetric);
    var NoopObservableMetric = /** @class */function () {
      function NoopObservableMetric() {}
      NoopObservableMetric.prototype.addCallback = function (_callback) {};
      NoopObservableMetric.prototype.removeCallback = function (_callback) {};
      return NoopObservableMetric;
    }();
    var NoopObservableCounterMetric = /** @class */function (_super) {
      __extends$5(NoopObservableCounterMetric, _super);
      function NoopObservableCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableCounterMetric;
    }(NoopObservableMetric);
    var NoopObservableGaugeMetric = /** @class */function (_super) {
      __extends$5(NoopObservableGaugeMetric, _super);
      function NoopObservableGaugeMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableGaugeMetric;
    }(NoopObservableMetric);
    var NoopObservableUpDownCounterMetric = /** @class */function (_super) {
      __extends$5(NoopObservableUpDownCounterMetric, _super);
      function NoopObservableUpDownCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableUpDownCounterMetric;
    }(NoopObservableMetric);
    var NOOP_METER = new NoopMeter();
    // Synchronous instruments
    var NOOP_COUNTER_METRIC = new NoopCounterMetric();
    var NOOP_GAUGE_METRIC = new NoopGaugeMetric();
    var NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    var NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    // Asynchronous instruments
    var NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    var NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    var NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var defaultTextMapGetter = {
      get: function (carrier, key) {
        if (carrier == null) {
          return undefined;
        }
        return carrier[key];
      },
      keys: function (carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }
    };
    var defaultTextMapSetter = {
      set: function (carrier, key, value) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value;
      }
    };

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __read$b = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray$4 = undefined && undefined.__spreadArray || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var NoopContextManager = /** @class */function () {
      function NoopContextManager() {}
      NoopContextManager.prototype.active = function () {
        return ROOT_CONTEXT;
      };
      NoopContextManager.prototype.with = function (_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray$4([thisArg], __read$b(args), false));
      };
      NoopContextManager.prototype.bind = function (_context, target) {
        return target;
      };
      NoopContextManager.prototype.enable = function () {
        return this;
      };
      NoopContextManager.prototype.disable = function () {
        return this;
      };
      return NoopContextManager;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __read$a = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray$3 = undefined && undefined.__spreadArray || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var API_NAME$3 = 'context';
    var NOOP_CONTEXT_MANAGER = new NoopContextManager();
    /**
     * Singleton object which represents the entry point to the OpenTelemetry Context API
     */
    var ContextAPI = /** @class */function () {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      function ContextAPI() {}
      /** Get the singleton instance of the Context API */
      ContextAPI.getInstance = function () {
        if (!this._instance) {
          this._instance = new ContextAPI();
        }
        return this._instance;
      };
      /**
       * Set the current context manager.
       *
       * @returns true if the context manager was successfully registered, else false
       */
      ContextAPI.prototype.setGlobalContextManager = function (contextManager) {
        return registerGlobal(API_NAME$3, contextManager, DiagAPI.instance());
      };
      /**
       * Get the currently active context
       */
      ContextAPI.prototype.active = function () {
        return this._getContextManager().active();
      };
      /**
       * Execute a function with an active context
       *
       * @param context context to be active during function execution
       * @param fn function to execute in a context
       * @param thisArg optional receiver to be used for calling fn
       * @param args optional arguments forwarded to fn
       */
      ContextAPI.prototype.with = function (context, fn, thisArg) {
        var _a;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return (_a = this._getContextManager()).with.apply(_a, __spreadArray$3([context, fn, thisArg], __read$a(args), false));
      };
      /**
       * Bind a context to a target function or event emitter
       *
       * @param context context to bind to the event emitter or function. Defaults to the currently active context
       * @param target function or event emitter to bind
       */
      ContextAPI.prototype.bind = function (context, target) {
        return this._getContextManager().bind(context, target);
      };
      ContextAPI.prototype._getContextManager = function () {
        return getGlobal(API_NAME$3) || NOOP_CONTEXT_MANAGER;
      };
      /** Disable and remove the global context manager */
      ContextAPI.prototype.disable = function () {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME$3, DiagAPI.instance());
      };
      return ContextAPI;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var TraceFlags;
    (function (TraceFlags) {
      /** Represents no flag set. */
      TraceFlags[TraceFlags["NONE"] = 0] = "NONE";
      /** Bit to represent whether trace is sampled in trace flags. */
      TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags || (TraceFlags = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var INVALID_SPANID = '0000000000000000';
    var INVALID_TRACEID = '00000000000000000000000000000000';
    var INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE
    };

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * The NonRecordingSpan is the default {@link Span} that is used when no Span
     * implementation is available. All operations are no-op including context
     * propagation.
     */
    var NonRecordingSpan = /** @class */function () {
      function NonRecordingSpan(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      // Returns a SpanContext.
      NonRecordingSpan.prototype.spanContext = function () {
        return this._spanContext;
      };
      // By default does nothing
      NonRecordingSpan.prototype.setAttribute = function (_key, _value) {
        return this;
      };
      // By default does nothing
      NonRecordingSpan.prototype.setAttributes = function (_attributes) {
        return this;
      };
      // By default does nothing
      NonRecordingSpan.prototype.addEvent = function (_name, _attributes) {
        return this;
      };
      NonRecordingSpan.prototype.addLink = function (_link) {
        return this;
      };
      NonRecordingSpan.prototype.addLinks = function (_links) {
        return this;
      };
      // By default does nothing
      NonRecordingSpan.prototype.setStatus = function (_status) {
        return this;
      };
      // By default does nothing
      NonRecordingSpan.prototype.updateName = function (_name) {
        return this;
      };
      // By default does nothing
      NonRecordingSpan.prototype.end = function (_endTime) {};
      // isRecording always returns false for NonRecordingSpan.
      NonRecordingSpan.prototype.isRecording = function () {
        return false;
      };
      // By default does nothing
      NonRecordingSpan.prototype.recordException = function (_exception, _time) {};
      return NonRecordingSpan;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * span key
     */
    var SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');
    /**
     * Return the span if one exists
     *
     * @param context context to get span from
     */
    function getSpan(context) {
      return context.getValue(SPAN_KEY) || undefined;
    }
    /**
     * Gets the span from the current context, if one exists.
     */
    function getActiveSpan() {
      return getSpan(ContextAPI.getInstance().active());
    }
    /**
     * Set the span on a context
     *
     * @param context context to use as parent
     * @param span span to set active
     */
    function setSpan(context, span) {
      return context.setValue(SPAN_KEY, span);
    }
    /**
     * Remove current span stored in the context
     *
     * @param context context to delete span from
     */
    function deleteSpan(context) {
      return context.deleteValue(SPAN_KEY);
    }
    /**
     * Wrap span context in a NoopSpan and set as span in a new
     * context
     *
     * @param context context to set active span on
     * @param spanContext span context to be wrapped
     */
    function setSpanContext(context, spanContext) {
      return setSpan(context, new NonRecordingSpan(spanContext));
    }
    /**
     * Get the span context of the span if it exists.
     *
     * @param context context to get values from
     */
    function getSpanContext(context) {
      var _a;
      return (_a = getSpan(context)) === null || _a === void 0 ? void 0 : _a.spanContext();
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
    function isValidTraceId(traceId) {
      return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
    }
    function isValidSpanId(spanId) {
      return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
    }
    /**
     * Returns true if this {@link SpanContext} is valid.
     * @return true if this {@link SpanContext} is valid.
     */
    function isSpanContextValid(spanContext) {
      return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
    }
    /**
     * Wrap the given {@link SpanContext} in a new non-recording {@link Span}
     *
     * @param spanContext span context to be wrapped
     * @returns a new non-recording {@link Span} with the provided context
     */
    function wrapSpanContext(spanContext) {
      return new NonRecordingSpan(spanContext);
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var contextApi = ContextAPI.getInstance();
    /**
     * No-op implementations of {@link Tracer}.
     */
    var NoopTracer = /** @class */function () {
      function NoopTracer() {}
      // startSpan starts a noop span.
      NoopTracer.prototype.startSpan = function (name, options, context) {
        if (context === void 0) {
          context = contextApi.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context && getSpanContext(context);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, undefined, span);
      };
      return NoopTracer;
    }();
    function isSpanContext(spanContext) {
      return typeof spanContext === 'object' && typeof spanContext['spanId'] === 'string' && typeof spanContext['traceId'] === 'string' && typeof spanContext['traceFlags'] === 'number';
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var NOOP_TRACER = new NoopTracer();
    /**
     * Proxy tracer provided by the proxy tracer provider
     */
    var ProxyTracer = /** @class */function () {
      function ProxyTracer(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
      }
      ProxyTracer.prototype.startSpan = function (name, options, context) {
        return this._getTracer().startSpan(name, options, context);
      };
      ProxyTracer.prototype.startActiveSpan = function (_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      };
      /**
       * Try to get a tracer from the proxy tracer provider.
       * If the proxy tracer provider has no delegate, return a noop tracer.
       */
      ProxyTracer.prototype._getTracer = function () {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
          return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
      };
      return ProxyTracer;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * An implementation of the {@link TracerProvider} which returns an impotent
     * Tracer for all calls to `getTracer`.
     *
     * All operations are no-op.
     */
    var NoopTracerProvider = /** @class */function () {
      function NoopTracerProvider() {}
      NoopTracerProvider.prototype.getTracer = function (_name, _version, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
    /**
     * Tracer provider which provides {@link ProxyTracer}s.
     *
     * Before a delegate is set, tracers provided are NoOp.
     *   When a delegate is set, traces are provided from the delegate.
     *   When a delegate is set after tracers have already been provided,
     *   all tracers already provided will use the provided delegate implementation.
     */
    var ProxyTracerProvider = /** @class */function () {
      function ProxyTracerProvider() {}
      /**
       * Get a {@link ProxyTracer}
       */
      ProxyTracerProvider.prototype.getTracer = function (name, version, options) {
        var _a;
        return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name, version, options);
      };
      ProxyTracerProvider.prototype.getDelegate = function () {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
      };
      /**
       * Set the delegate tracer provider
       */
      ProxyTracerProvider.prototype.setDelegate = function (delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider.prototype.getDelegateTracer = function (name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
      };
      return ProxyTracerProvider;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.
     * A sampling decision that determines how a {@link Span} will be recorded
     * and collected.
     */
    var SamplingDecision$1;
    (function (SamplingDecision) {
      /**
       * `Span.isRecording() === false`, span will not be recorded and all events
       * and attributes will be dropped.
       */
      SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
      /**
       * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
       * MUST NOT be set.
       */
      SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
      /**
       * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
       * MUST be set.
       */
      SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision$1 || (SamplingDecision$1 = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var SpanKind;
    (function (SpanKind) {
      /** Default value. Indicates that the span is used internally. */
      SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
      /**
       * Indicates that the span covers server-side handling of an RPC or other
       * remote request.
       */
      SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
      /**
       * Indicates that the span covers the client-side wrapper around an RPC or
       * other remote request.
       */
      SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
      /**
       * Indicates that the span describes producer sending a message to a
       * broker. Unlike client and server, there is no direct critical path latency
       * relationship between producer and consumer spans.
       */
      SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
      /**
       * Indicates that the span describes consumer receiving a message from a
       * broker. Unlike client and server, there is no direct critical path latency
       * relationship between producer and consumer spans.
       */
      SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind || (SpanKind = {}));

    /**
     * An enumeration of status codes.
     */
    var SpanStatusCode;
    (function (SpanStatusCode) {
      /**
       * The default status.
       */
      SpanStatusCode[SpanStatusCode["UNSET"] = 0] = "UNSET";
      /**
       * The operation has been validated by an Application developer or
       * Operator to have completed successfully.
       */
      SpanStatusCode[SpanStatusCode["OK"] = 1] = "OK";
      /**
       * The operation contains an error.
       */
      SpanStatusCode[SpanStatusCode["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode || (SpanStatusCode = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Split module-level variable definition into separate files to allow
    // tree-shaking on each api instance.
    /** Entrypoint for context API */
    var context = ContextAPI.getInstance();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Split module-level variable definition into separate files to allow
    // tree-shaking on each api instance.
    /**
     * Entrypoint for Diag API.
     * Defines Diagnostic handler used for internal diagnostic logging operations.
     * The default provides a Noop DiagLogger implementation which may be changed via the
     * diag.setLogger(logger: DiagLogger) function.
     */
    var diag = DiagAPI.instance();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * An implementation of the {@link MeterProvider} which returns an impotent Meter
     * for all calls to `getMeter`
     */
    var NoopMeterProvider = /** @class */function () {
      function NoopMeterProvider() {}
      NoopMeterProvider.prototype.getMeter = function (_name, _version, _options) {
        return NOOP_METER;
      };
      return NoopMeterProvider;
    }();
    var NOOP_METER_PROVIDER = new NoopMeterProvider();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var API_NAME$2 = 'metrics';
    /**
     * Singleton object which represents the entry point to the OpenTelemetry Metrics API
     */
    var MetricsAPI = /** @class */function () {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      function MetricsAPI() {}
      /** Get the singleton instance of the Metrics API */
      MetricsAPI.getInstance = function () {
        if (!this._instance) {
          this._instance = new MetricsAPI();
        }
        return this._instance;
      };
      /**
       * Set the current global meter provider.
       * Returns true if the meter provider was successfully registered, else false.
       */
      MetricsAPI.prototype.setGlobalMeterProvider = function (provider) {
        return registerGlobal(API_NAME$2, provider, DiagAPI.instance());
      };
      /**
       * Returns the global meter provider.
       */
      MetricsAPI.prototype.getMeterProvider = function () {
        return getGlobal(API_NAME$2) || NOOP_METER_PROVIDER;
      };
      /**
       * Returns a meter from the global meter provider.
       */
      MetricsAPI.prototype.getMeter = function (name, version, options) {
        return this.getMeterProvider().getMeter(name, version, options);
      };
      /** Remove the global meter provider */
      MetricsAPI.prototype.disable = function () {
        unregisterGlobal(API_NAME$2, DiagAPI.instance());
      };
      return MetricsAPI;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Split module-level variable definition into separate files to allow
    // tree-shaking on each api instance.
    /** Entrypoint for metrics API */
    var metrics = MetricsAPI.getInstance();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * No-op implementations of {@link TextMapPropagator}.
     */
    var NoopTextMapPropagator = /** @class */function () {
      function NoopTextMapPropagator() {}
      /** Noop inject function does nothing */
      NoopTextMapPropagator.prototype.inject = function (_context, _carrier) {};
      /** Noop extract function does nothing and returns the input context */
      NoopTextMapPropagator.prototype.extract = function (context, _carrier) {
        return context;
      };
      NoopTextMapPropagator.prototype.fields = function () {
        return [];
      };
      return NoopTextMapPropagator;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Baggage key
     */
    var BAGGAGE_KEY = createContextKey('OpenTelemetry Baggage Key');
    /**
     * Retrieve the current baggage from the given context
     *
     * @param {Context} Context that manage all context values
     * @returns {Baggage} Extracted baggage from the context
     */
    function getBaggage(context) {
      return context.getValue(BAGGAGE_KEY) || undefined;
    }
    /**
     * Retrieve the current baggage from the active/current context
     *
     * @returns {Baggage} Extracted baggage from the context
     */
    function getActiveBaggage() {
      return getBaggage(ContextAPI.getInstance().active());
    }
    /**
     * Store a baggage in the given context
     *
     * @param {Context} Context that manage all context values
     * @param {Baggage} baggage that will be set in the actual context
     */
    function setBaggage(context, baggage) {
      return context.setValue(BAGGAGE_KEY, baggage);
    }
    /**
     * Delete the baggage stored in the given context
     *
     * @param {Context} Context that manage all context values
     */
    function deleteBaggage(context) {
      return context.deleteValue(BAGGAGE_KEY);
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var API_NAME$1 = 'propagation';
    var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
    /**
     * Singleton object which represents the entry point to the OpenTelemetry Propagation API
     */
    var PropagationAPI = /** @class */function () {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      function PropagationAPI() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.getActiveBaggage = getActiveBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
      }
      /** Get the singleton instance of the Propagator API */
      PropagationAPI.getInstance = function () {
        if (!this._instance) {
          this._instance = new PropagationAPI();
        }
        return this._instance;
      };
      /**
       * Set the current propagator.
       *
       * @returns true if the propagator was successfully registered, else false
       */
      PropagationAPI.prototype.setGlobalPropagator = function (propagator) {
        return registerGlobal(API_NAME$1, propagator, DiagAPI.instance());
      };
      /**
       * Inject context into a carrier to be propagated inter-process
       *
       * @param context Context carrying tracing data to inject
       * @param carrier carrier to inject context into
       * @param setter Function used to set values on the carrier
       */
      PropagationAPI.prototype.inject = function (context, carrier, setter) {
        if (setter === void 0) {
          setter = defaultTextMapSetter;
        }
        return this._getGlobalPropagator().inject(context, carrier, setter);
      };
      /**
       * Extract context from a carrier
       *
       * @param context Context which the newly created context will inherit from
       * @param carrier Carrier to extract context from
       * @param getter Function used to extract keys from a carrier
       */
      PropagationAPI.prototype.extract = function (context, carrier, getter) {
        if (getter === void 0) {
          getter = defaultTextMapGetter;
        }
        return this._getGlobalPropagator().extract(context, carrier, getter);
      };
      /**
       * Return a list of all fields which may be used by the propagator.
       */
      PropagationAPI.prototype.fields = function () {
        return this._getGlobalPropagator().fields();
      };
      /** Remove the global propagator */
      PropagationAPI.prototype.disable = function () {
        unregisterGlobal(API_NAME$1, DiagAPI.instance());
      };
      PropagationAPI.prototype._getGlobalPropagator = function () {
        return getGlobal(API_NAME$1) || NOOP_TEXT_MAP_PROPAGATOR;
      };
      return PropagationAPI;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Split module-level variable definition into separate files to allow
    // tree-shaking on each api instance.
    /** Entrypoint for propagation API */
    var propagation = PropagationAPI.getInstance();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var API_NAME = 'trace';
    /**
     * Singleton object which represents the entry point to the OpenTelemetry Tracing API
     */
    var TraceAPI = /** @class */function () {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      function TraceAPI() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      /** Get the singleton instance of the Trace API */
      TraceAPI.getInstance = function () {
        if (!this._instance) {
          this._instance = new TraceAPI();
        }
        return this._instance;
      };
      /**
       * Set the current global tracer.
       *
       * @returns true if the tracer provider was successfully registered, else false
       */
      TraceAPI.prototype.setGlobalTracerProvider = function (provider) {
        var success = registerGlobal(API_NAME, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      };
      /**
       * Returns the global tracer provider.
       */
      TraceAPI.prototype.getTracerProvider = function () {
        return getGlobal(API_NAME) || this._proxyTracerProvider;
      };
      /**
       * Returns a tracer from the global tracer provider.
       */
      TraceAPI.prototype.getTracer = function (name, version) {
        return this.getTracerProvider().getTracer(name, version);
      };
      /** Remove the global tracer provider */
      TraceAPI.prototype.disable = function () {
        unregisterGlobal(API_NAME, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Split module-level variable definition into separate files to allow
    // tree-shaking on each api instance.
    /** Entrypoint for trace API */
    var trace = TraceAPI.getInstance();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var NoopLogger = /** @class */function () {
      function NoopLogger() {}
      NoopLogger.prototype.emit = function (_logRecord) {};
      return NoopLogger;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var NoopLoggerProvider = /** @class */function () {
      function NoopLoggerProvider() {}
      NoopLoggerProvider.prototype.getLogger = function (_name, _version, _options) {
        return new NoopLogger();
      };
      return NoopLoggerProvider;
    }();
    var NOOP_LOGGER_PROVIDER = new NoopLoggerProvider();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Updates to this file should also be replicated to @opentelemetry/api and
    // @opentelemetry/core too.
    /**
     * - globalThis (New standard)
     * - self (Will return the current window instance for supported browsers)
     * - window (fallback for older browser implementations)
     * - global (NodeJS implementation)
     * - <object> (When all else fails)
     */
    /** only globals that common to node and browsers are allowed */
    // eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
    var _globalThis$1 = typeof globalThis === 'object' ? globalThis : typeof self === 'object' ? self : typeof window === 'object' ? window : typeof global === 'object' ? global : {};

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var GLOBAL_LOGS_API_KEY = Symbol.for('io.opentelemetry.js.api.logs');
    var _global = _globalThis$1;
    /**
     * Make a function which accepts a version integer and returns the instance of an API if the version
     * is compatible, or a fallback version (usually NOOP) if it is not.
     *
     * @param requiredVersion Backwards compatibility version which is required to return the instance
     * @param instance Instance which should be returned if the required version is compatible
     * @param fallback Fallback instance, usually NOOP, which will be returned if the required version is not compatible
     */
    function makeGetter(requiredVersion, instance, fallback) {
      return function (version) {
        return version === requiredVersion ? instance : fallback;
      };
    }
    /**
     * A number which should be incremented each time a backwards incompatible
     * change is made to the API. This number is used when an API package
     * attempts to access the global API to ensure it is getting a compatible
     * version. If the global API is not compatible with the API package
     * attempting to get it, a NOOP API implementation will be returned.
     */
    var API_BACKWARDS_COMPATIBILITY_VERSION = 1;

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var LogsAPI = /** @class */function () {
      function LogsAPI() {}
      LogsAPI.getInstance = function () {
        if (!this._instance) {
          this._instance = new LogsAPI();
        }
        return this._instance;
      };
      LogsAPI.prototype.setGlobalLoggerProvider = function (provider) {
        if (_global[GLOBAL_LOGS_API_KEY]) {
          return this.getLoggerProvider();
        }
        _global[GLOBAL_LOGS_API_KEY] = makeGetter(API_BACKWARDS_COMPATIBILITY_VERSION, provider, NOOP_LOGGER_PROVIDER);
        return provider;
      };
      /**
       * Returns the global logger provider.
       *
       * @returns LoggerProvider
       */
      LogsAPI.prototype.getLoggerProvider = function () {
        var _a, _b;
        return (_b = (_a = _global[GLOBAL_LOGS_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(_global, API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NOOP_LOGGER_PROVIDER;
      };
      /**
       * Returns a logger from the global logger provider.
       *
       * @returns Logger
       */
      LogsAPI.prototype.getLogger = function (name, version, options) {
        return this.getLoggerProvider().getLogger(name, version, options);
      };
      /** Remove the global logger provider */
      LogsAPI.prototype.disable = function () {
        delete _global[GLOBAL_LOGS_API_KEY];
      };
      return LogsAPI;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var logs = LogsAPI.getInstance();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Enable instrumentations
     * @param instrumentations
     * @param tracerProvider
     * @param meterProvider
     */
    function enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider) {
      for (var i = 0, j = instrumentations.length; i < j; i++) {
        var instrumentation = instrumentations[i];
        if (tracerProvider) {
          instrumentation.setTracerProvider(tracerProvider);
        }
        if (meterProvider) {
          instrumentation.setMeterProvider(meterProvider);
        }
        if (loggerProvider && instrumentation.setLoggerProvider) {
          instrumentation.setLoggerProvider(loggerProvider);
        }
        // instrumentations have been already enabled during creation
        // so enable only if user prevented that by setting enabled to false
        // this is to prevent double enabling but when calling register all
        // instrumentations should be now enabled
        if (!instrumentation.getConfig().enabled) {
          instrumentation.enable();
        }
      }
    }
    /**
     * Disable instrumentations
     * @param instrumentations
     */
    function disableInstrumentations(instrumentations) {
      instrumentations.forEach(function (instrumentation) {
        return instrumentation.disable();
      });
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * It will register instrumentations and plugins
     * @param options
     * @return returns function to unload instrumentation and plugins that were
     *   registered
     */
    function registerInstrumentations(options) {
      var _a, _b;
      var tracerProvider = options.tracerProvider || trace.getTracerProvider();
      var meterProvider = options.meterProvider || metrics.getMeterProvider();
      var loggerProvider = options.loggerProvider || logs.getLoggerProvider();
      var instrumentations = (_b = (_a = options.instrumentations) === null || _a === void 0 ? void 0 : _a.flat()) !== null && _b !== void 0 ? _b : [];
      enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider);
      return function () {
        disableInstrumentations(instrumentations);
      };
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function isFunction$1(funktion) {
      return typeof funktion === 'function';
    }

    // Default to complaining loudly when things don't go according to plan.
    var logger = console.error.bind(console);

    // Sets a property on an object, preserving its enumerability.
    // This function assumes that the property is already writable.
    function defineProperty(obj, name, value) {
      var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
      Object.defineProperty(obj, name, {
        configurable: true,
        enumerable: enumerable,
        writable: true,
        value: value
      });
    }

    // Keep initialization idempotent.
    function shimmer(options) {
      if (options && options.logger) {
        if (!isFunction$1(options.logger)) logger("new logger isn't a function, not replacing");else logger = options.logger;
      }
    }
    function wrap(nodule, name, wrapper) {
      if (!nodule || !nodule[name]) {
        logger('no original function ' + name + ' to wrap');
        return;
      }
      if (!wrapper) {
        logger('no wrapper function');
        logger(new Error().stack);
        return;
      }
      if (!isFunction$1(nodule[name]) || !isFunction$1(wrapper)) {
        logger('original object and wrapper must be functions');
        return;
      }
      var original = nodule[name];
      var wrapped = wrapper(original, name);
      defineProperty(wrapped, '__original', original);
      defineProperty(wrapped, '__unwrap', function () {
        if (nodule[name] === wrapped) defineProperty(nodule, name, original);
      });
      defineProperty(wrapped, '__wrapped', true);
      defineProperty(nodule, name, wrapped);
      return wrapped;
    }
    function massWrap(nodules, names, wrapper) {
      if (!nodules) {
        logger('must provide one or more modules to patch');
        logger(new Error().stack);
        return;
      } else if (!Array.isArray(nodules)) {
        nodules = [nodules];
      }
      if (!(names && Array.isArray(names))) {
        logger('must provide one or more functions to wrap on modules');
        return;
      }
      nodules.forEach(function (nodule) {
        names.forEach(function (name) {
          wrap(nodule, name, wrapper);
        });
      });
    }
    function unwrap(nodule, name) {
      if (!nodule || !nodule[name]) {
        logger('no function to unwrap.');
        logger(new Error().stack);
        return;
      }
      if (!nodule[name].__unwrap) {
        logger('no original to unwrap to -- has ' + name + ' already been unwrapped?');
      } else {
        return nodule[name].__unwrap();
      }
    }
    function massUnwrap(nodules, names) {
      if (!nodules) {
        logger('must provide one or more modules to patch');
        logger(new Error().stack);
        return;
      } else if (!Array.isArray(nodules)) {
        nodules = [nodules];
      }
      if (!(names && Array.isArray(names))) {
        logger('must provide one or more functions to unwrap on modules');
        return;
      }
      nodules.forEach(function (nodule) {
        names.forEach(function (name) {
          unwrap(nodule, name);
        });
      });
    }
    shimmer.wrap = wrap;
    shimmer.massWrap = massWrap;
    shimmer.unwrap = unwrap;
    shimmer.massUnwrap = massUnwrap;
    var shimmer_1 = shimmer;

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var TMP_EXCEPTION_TYPE = 'exception.type';
    var TMP_EXCEPTION_MESSAGE = 'exception.message';
    var TMP_EXCEPTION_STACKTRACE = 'exception.stacktrace';
    /**
     * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.
     */
    var SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;
    /**
     * The exception message.
     */
    var SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;
    /**
     * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.
     */
    var SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var TMP_PROCESS_RUNTIME_NAME = 'process.runtime.name';
    var TMP_SERVICE_NAME = 'service.name';
    var TMP_TELEMETRY_SDK_NAME = 'telemetry.sdk.name';
    var TMP_TELEMETRY_SDK_LANGUAGE = 'telemetry.sdk.language';
    var TMP_TELEMETRY_SDK_VERSION = 'telemetry.sdk.version';
    /**
     * The name of the runtime of this process. For compiled native binaries, this SHOULD be the name of the compiler.
     */
    var SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;
    /**
     * Logical name of the service.
     *
     * Note: MUST be the same for all instances of horizontally scaled services. If the value was not specified, SDKs MUST fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md#process), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value MUST be set to `unknown_service`.
     */
    var SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;
    /**
     * The name of the telemetry SDK as defined above.
     */
    var SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;
    /**
     * The language of the telemetry SDK.
     */
    var SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;
    /**
     * The version string of the telemetry SDK.
     */
    var SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;
    var TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS = 'webjs';
    /**
     * The language of the telemetry SDK.
     */
    var TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS;

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var SUPPRESS_TRACING_KEY = createContextKey('OpenTelemetry SDK Context Key SUPPRESS_TRACING');
    function suppressTracing(context) {
      return context.setValue(SUPPRESS_TRACING_KEY, true);
    }
    function isTracingSuppressed(context) {
      return context.getValue(SUPPRESS_TRACING_KEY) === true;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var BAGGAGE_KEY_PAIR_SEPARATOR = '=';
    var BAGGAGE_PROPERTIES_SEPARATOR = ';';
    var BAGGAGE_ITEMS_SEPARATOR = ',';
    // Name of the http header used to propagate the baggage
    var BAGGAGE_HEADER = 'baggage';
    // Maximum number of name-value pairs allowed by w3c spec
    var BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    // Maximum number of bytes per a single name-value pair allowed by w3c spec
    var BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    // Maximum total length of all name-value pairs allowed by w3c spec
    var BAGGAGE_MAX_TOTAL_LENGTH = 8192;

    var __read$9 = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    function serializeKeyPairs(keyPairs) {
      return keyPairs.reduce(function (hValue, current) {
        var value = "" + hValue + (hValue !== '' ? BAGGAGE_ITEMS_SEPARATOR : '') + current;
        return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
      }, '');
    }
    function getKeyPairs(baggage) {
      return baggage.getAllEntries().map(function (_a) {
        var _b = __read$9(_a, 2),
          key = _b[0],
          value = _b[1];
        var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
        // include opaque metadata if provided
        // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation
        if (value.metadata !== undefined) {
          entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
      });
    }
    function parsePairKeyValue(entry) {
      var valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);
      if (valueProps.length <= 0) return;
      var keyPairPart = valueProps.shift();
      if (!keyPairPart) return;
      var separatorIndex = keyPairPart.indexOf(BAGGAGE_KEY_PAIR_SEPARATOR);
      if (separatorIndex <= 0) return;
      var key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
      var value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
      var metadata;
      if (valueProps.length > 0) {
        metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR));
      }
      return {
        key: key,
        value: value,
        metadata: metadata
      };
    }
    /**
     * Parse a string serialized in the baggage HTTP Format (without metadata):
     * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md
     */
    function parseKeyPairsIntoRecord(value) {
      if (typeof value !== 'string' || value.length === 0) return {};
      return value.split(BAGGAGE_ITEMS_SEPARATOR).map(function (entry) {
        return parsePairKeyValue(entry);
      }).filter(function (keyPair) {
        return keyPair !== undefined && keyPair.value.length > 0;
      }).reduce(function (headers, keyPair) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        headers[keyPair.key] = keyPair.value;
        return headers;
      }, {});
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Propagates {@link Baggage} through Context format propagation.
     *
     * Based on the Baggage specification:
     * https://w3c.github.io/baggage/
     */
    var W3CBaggagePropagator = /** @class */function () {
      function W3CBaggagePropagator() {}
      W3CBaggagePropagator.prototype.inject = function (context, carrier, setter) {
        var baggage = propagation.getBaggage(context);
        if (!baggage || isTracingSuppressed(context)) return;
        var keyPairs = getKeyPairs(baggage).filter(function (pair) {
          return pair.length <= BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        }).slice(0, BAGGAGE_MAX_NAME_VALUE_PAIRS);
        var headerValue = serializeKeyPairs(keyPairs);
        if (headerValue.length > 0) {
          setter.set(carrier, BAGGAGE_HEADER, headerValue);
        }
      };
      W3CBaggagePropagator.prototype.extract = function (context, carrier, getter) {
        var headerValue = getter.get(carrier, BAGGAGE_HEADER);
        var baggageString = Array.isArray(headerValue) ? headerValue.join(BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString) return context;
        var baggage = {};
        if (baggageString.length === 0) {
          return context;
        }
        var pairs = baggageString.split(BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach(function (entry) {
          var keyPair = parsePairKeyValue(entry);
          if (keyPair) {
            var baggageEntry = {
              value: keyPair.value
            };
            if (keyPair.metadata) {
              baggageEntry.metadata = keyPair.metadata;
            }
            baggage[keyPair.key] = baggageEntry;
          }
        });
        if (Object.entries(baggage).length === 0) {
          return context;
        }
        return propagation.setBaggage(context, propagation.createBaggage(baggage));
      };
      W3CBaggagePropagator.prototype.fields = function () {
        return [BAGGAGE_HEADER];
      };
      return W3CBaggagePropagator;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __values$4 = undefined && undefined.__values || function (o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function () {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read$8 = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    function sanitizeAttributes(attributes) {
      var e_1, _a;
      var out = {};
      if (typeof attributes !== 'object' || attributes == null) {
        return out;
      }
      try {
        for (var _b = __values$4(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read$8(_c.value, 2),
            key = _d[0],
            val = _d[1];
          if (!isAttributeKey(key)) {
            diag.warn("Invalid attribute key: " + key);
            continue;
          }
          if (!isAttributeValue(val)) {
            diag.warn("Invalid attribute value set for key: " + key);
            continue;
          }
          if (Array.isArray(val)) {
            out[key] = val.slice();
          } else {
            out[key] = val;
          }
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return out;
    }
    function isAttributeKey(key) {
      return typeof key === 'string' && key.length > 0;
    }
    function isAttributeValue(val) {
      if (val == null) {
        return true;
      }
      if (Array.isArray(val)) {
        return isHomogeneousAttributeValueArray(val);
      }
      return isValidPrimitiveAttributeValue(val);
    }
    function isHomogeneousAttributeValueArray(arr) {
      var e_2, _a;
      var type;
      try {
        for (var arr_1 = __values$4(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
          var element = arr_1_1.value;
          // null/undefined elements are allowed
          if (element == null) continue;
          if (!type) {
            if (isValidPrimitiveAttributeValue(element)) {
              type = typeof element;
              continue;
            }
            // encountered an invalid primitive
            return false;
          }
          if (typeof element === type) {
            continue;
          }
          return false;
        }
      } catch (e_2_1) {
        e_2 = {
          error: e_2_1
        };
      } finally {
        try {
          if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
      return true;
    }
    function isValidPrimitiveAttributeValue(val) {
      switch (typeof val) {
        case 'number':
        case 'boolean':
        case 'string':
          return true;
      }
      return false;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Returns a function that logs an error using the provided logger, or a
     * console logger if one was not provided.
     */
    function loggingErrorHandler() {
      return function (ex) {
        diag.error(stringifyException(ex));
      };
    }
    /**
     * Converts an exception into a string representation
     * @param {Exception} ex
     */
    function stringifyException(ex) {
      if (typeof ex === 'string') {
        return ex;
      } else {
        return JSON.stringify(flattenException(ex));
      }
    }
    /**
     * Flattens an exception into key-value pairs by traversing the prototype chain
     * and coercing values to strings. Duplicate properties will not be overwritten;
     * the first insert wins.
     */
    function flattenException(ex) {
      var result = {};
      var current = ex;
      while (current !== null) {
        Object.getOwnPropertyNames(current).forEach(function (propertyName) {
          if (result[propertyName]) return;
          var value = current[propertyName];
          if (value) {
            result[propertyName] = String(value);
          }
        });
        current = Object.getPrototypeOf(current);
      }
      return result;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /** The global error handler delegate */
    var delegateHandler = loggingErrorHandler();
    /**
     * Return the global error handler
     * @param {Exception} ex
     */
    function globalErrorHandler(ex) {
      try {
        delegateHandler(ex);
      } catch (_a) {} // eslint-disable-line no-empty
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var TracesSamplerValues;
    (function (TracesSamplerValues) {
      TracesSamplerValues["AlwaysOff"] = "always_off";
      TracesSamplerValues["AlwaysOn"] = "always_on";
      TracesSamplerValues["ParentBasedAlwaysOff"] = "parentbased_always_off";
      TracesSamplerValues["ParentBasedAlwaysOn"] = "parentbased_always_on";
      TracesSamplerValues["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
      TracesSamplerValues["TraceIdRatio"] = "traceidratio";
    })(TracesSamplerValues || (TracesSamplerValues = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var DEFAULT_LIST_SEPARATOR = ',';
    /**
     * Environment interface to define all names
     */
    var ENVIRONMENT_BOOLEAN_KEYS = ['OTEL_SDK_DISABLED'];
    function isEnvVarABoolean(key) {
      return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_NUMBERS_KEYS = ['OTEL_BSP_EXPORT_TIMEOUT', 'OTEL_BSP_MAX_EXPORT_BATCH_SIZE', 'OTEL_BSP_MAX_QUEUE_SIZE', 'OTEL_BSP_SCHEDULE_DELAY', 'OTEL_BLRP_EXPORT_TIMEOUT', 'OTEL_BLRP_MAX_EXPORT_BATCH_SIZE', 'OTEL_BLRP_MAX_QUEUE_SIZE', 'OTEL_BLRP_SCHEDULE_DELAY', 'OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT', 'OTEL_ATTRIBUTE_COUNT_LIMIT', 'OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT', 'OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT', 'OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT', 'OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT', 'OTEL_SPAN_EVENT_COUNT_LIMIT', 'OTEL_SPAN_LINK_COUNT_LIMIT', 'OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT', 'OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT', 'OTEL_EXPORTER_OTLP_TIMEOUT', 'OTEL_EXPORTER_OTLP_TRACES_TIMEOUT', 'OTEL_EXPORTER_OTLP_METRICS_TIMEOUT', 'OTEL_EXPORTER_OTLP_LOGS_TIMEOUT', 'OTEL_EXPORTER_JAEGER_AGENT_PORT'];
    function isEnvVarANumber(key) {
      return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_LISTS_KEYS = ['OTEL_NO_PATCH_MODULES', 'OTEL_PROPAGATORS'];
    function isEnvVarAList(key) {
      return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
    }
    var DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
    var DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
    var DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
    var DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
    /**
     * Default environment variables
     */
    var DEFAULT_ENVIRONMENT = {
      OTEL_SDK_DISABLED: false,
      CONTAINER_NAME: '',
      ECS_CONTAINER_METADATA_URI_V4: '',
      ECS_CONTAINER_METADATA_URI: '',
      HOSTNAME: '',
      KUBERNETES_SERVICE_HOST: '',
      NAMESPACE: '',
      OTEL_BSP_EXPORT_TIMEOUT: 30000,
      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BSP_MAX_QUEUE_SIZE: 2048,
      OTEL_BSP_SCHEDULE_DELAY: 5000,
      OTEL_BLRP_EXPORT_TIMEOUT: 30000,
      OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
      OTEL_BLRP_SCHEDULE_DELAY: 5000,
      OTEL_EXPORTER_JAEGER_AGENT_HOST: '',
      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
      OTEL_EXPORTER_JAEGER_ENDPOINT: '',
      OTEL_EXPORTER_JAEGER_PASSWORD: '',
      OTEL_EXPORTER_JAEGER_USER: '',
      OTEL_EXPORTER_OTLP_ENDPOINT: '',
      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: '',
      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: '',
      OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: '',
      OTEL_EXPORTER_OTLP_HEADERS: '',
      OTEL_EXPORTER_OTLP_TRACES_HEADERS: '',
      OTEL_EXPORTER_OTLP_METRICS_HEADERS: '',
      OTEL_EXPORTER_OTLP_LOGS_HEADERS: '',
      OTEL_EXPORTER_OTLP_TIMEOUT: 10000,
      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 10000,
      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 10000,
      OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 10000,
      OTEL_EXPORTER_ZIPKIN_ENDPOINT: 'http://localhost:9411/api/v2/spans',
      OTEL_LOG_LEVEL: DiagLogLevel.INFO,
      OTEL_NO_PATCH_MODULES: [],
      OTEL_PROPAGATORS: ['tracecontext', 'baggage'],
      OTEL_RESOURCE_ATTRIBUTES: '',
      OTEL_SERVICE_NAME: '',
      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
      OTEL_SPAN_LINK_COUNT_LIMIT: 128,
      OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
      OTEL_TRACES_EXPORTER: '',
      OTEL_TRACES_SAMPLER: TracesSamplerValues.ParentBasedAlwaysOn,
      OTEL_TRACES_SAMPLER_ARG: '',
      OTEL_LOGS_EXPORTER: '',
      OTEL_EXPORTER_OTLP_INSECURE: '',
      OTEL_EXPORTER_OTLP_TRACES_INSECURE: '',
      OTEL_EXPORTER_OTLP_METRICS_INSECURE: '',
      OTEL_EXPORTER_OTLP_LOGS_INSECURE: '',
      OTEL_EXPORTER_OTLP_CERTIFICATE: '',
      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: '',
      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: '',
      OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: '',
      OTEL_EXPORTER_OTLP_COMPRESSION: '',
      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: '',
      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: '',
      OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: '',
      OTEL_EXPORTER_OTLP_CLIENT_KEY: '',
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: '',
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: '',
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: '',
      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: '',
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: '',
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: '',
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: '',
      OTEL_EXPORTER_OTLP_PROTOCOL: 'http/protobuf',
      OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: 'http/protobuf',
      OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: 'http/protobuf',
      OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: 'http/protobuf',
      OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: 'cumulative'
    };
    /**
     * @param key
     * @param environment
     * @param values
     */
    function parseBoolean(key, environment, values) {
      if (typeof values[key] === 'undefined') {
        return;
      }
      var value = String(values[key]);
      // support case-insensitive "true"
      environment[key] = value.toLowerCase() === 'true';
    }
    /**
     * Parses a variable as number with number validation
     * @param name
     * @param environment
     * @param values
     * @param min
     * @param max
     */
    function parseNumber(name, environment, values, min, max) {
      if (min === void 0) {
        min = -Infinity;
      }
      if (max === void 0) {
        max = Infinity;
      }
      if (typeof values[name] !== 'undefined') {
        var value = Number(values[name]);
        if (!isNaN(value)) {
          if (value < min) {
            environment[name] = min;
          } else if (value > max) {
            environment[name] = max;
          } else {
            environment[name] = value;
          }
        }
      }
    }
    /**
     * Parses list-like strings from input into output.
     * @param name
     * @param environment
     * @param values
     * @param separator
     */
    function parseStringList(name, output, input, separator) {
      if (separator === void 0) {
        separator = DEFAULT_LIST_SEPARATOR;
      }
      var givenValue = input[name];
      if (typeof givenValue === 'string') {
        output[name] = givenValue.split(separator).map(function (v) {
          return v.trim();
        });
      }
    }
    // The support string -> DiagLogLevel mappings
    var logLevelMap = {
      ALL: DiagLogLevel.ALL,
      VERBOSE: DiagLogLevel.VERBOSE,
      DEBUG: DiagLogLevel.DEBUG,
      INFO: DiagLogLevel.INFO,
      WARN: DiagLogLevel.WARN,
      ERROR: DiagLogLevel.ERROR,
      NONE: DiagLogLevel.NONE
    };
    /**
     * Environmentally sets log level if valid log level string is provided
     * @param key
     * @param environment
     * @param values
     */
    function setLogLevelFromEnv(key, environment, values) {
      var value = values[key];
      if (typeof value === 'string') {
        var theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
          environment[key] = theLevel;
        }
      }
    }
    /**
     * Parses environment values
     * @param values
     */
    function parseEnvironment(values) {
      var environment = {};
      for (var env in DEFAULT_ENVIRONMENT) {
        var key = env;
        switch (key) {
          case 'OTEL_LOG_LEVEL':
            setLogLevelFromEnv(key, environment, values);
            break;
          default:
            if (isEnvVarABoolean(key)) {
              parseBoolean(key, environment, values);
            } else if (isEnvVarANumber(key)) {
              parseNumber(key, environment, values);
            } else if (isEnvVarAList(key)) {
              parseStringList(key, environment, values);
            } else {
              var value = values[key];
              if (typeof value !== 'undefined' && value !== null) {
                environment[key] = String(value);
              }
            }
        }
      }
      return environment;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Updates to this file should also be replicated to @opentelemetry/api too.
    /**
     * - globalThis (New standard)
     * - self (Will return the current window instance for supported browsers)
     * - window (fallback for older browser implementations)
     * - global (NodeJS implementation)
     * - <object> (When all else fails)
     */
    /** only globals that common to node and browsers are allowed */
    // eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
    var _globalThis = typeof globalThis === 'object' ? globalThis : typeof self === 'object' ? self : typeof window === 'object' ? window : typeof global === 'object' ? global : {};

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Gets the environment variables
     */
    function getEnv() {
      var globalEnv = parseEnvironment(_globalThis);
      return Object.assign({}, DEFAULT_ENVIRONMENT, globalEnv);
    }
    function getEnvWithoutDefaults() {
      return parseEnvironment(_globalThis);
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function intValue(charCode) {
      // 0-9
      if (charCode >= 48 && charCode <= 57) {
        return charCode - 48;
      }
      // a-f
      if (charCode >= 97 && charCode <= 102) {
        return charCode - 87;
      }
      // A-F
      return charCode - 55;
    }
    function hexToBinary(hexStr) {
      var buf = new Uint8Array(hexStr.length / 2);
      var offset = 0;
      for (var i = 0; i < hexStr.length; i += 2) {
        var hi = intValue(hexStr.charCodeAt(i));
        var lo = intValue(hexStr.charCodeAt(i + 1));
        buf[offset++] = hi << 4 | lo;
      }
      return buf;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var otperformance = performance;

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // this is autogenerated file, see scripts/version-update.js
    var VERSION$2 = '1.25.1';

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var _a;
    /** Constants describing the SDK in use */
    var SDK_INFO = (_a = {}, _a[SEMRESATTRS_TELEMETRY_SDK_NAME] = 'opentelemetry', _a[SEMRESATTRS_PROCESS_RUNTIME_NAME] = 'browser', _a[SEMRESATTRS_TELEMETRY_SDK_LANGUAGE] = TELEMETRYSDKLANGUAGEVALUES_WEBJS, _a[SEMRESATTRS_TELEMETRY_SDK_VERSION] = VERSION$2, _a);

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function unrefTimer(_timer) {}

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var NANOSECOND_DIGITS = 9;
    var NANOSECOND_DIGITS_IN_MILLIS = 6;
    var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
    var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
    /**
     * Converts a number of milliseconds from epoch to HrTime([seconds, remainder in nanoseconds]).
     * @param epochMillis
     */
    function millisToHrTime(epochMillis) {
      var epochSeconds = epochMillis / 1000;
      // Decimals only.
      var seconds = Math.trunc(epochSeconds);
      // Round sub-nanosecond accuracy to nanosecond.
      var nanos = Math.round(epochMillis % 1000 * MILLISECONDS_TO_NANOSECONDS);
      return [seconds, nanos];
    }
    function getTimeOrigin() {
      var timeOrigin = otperformance.timeOrigin;
      if (typeof timeOrigin !== 'number') {
        var perf = otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
      }
      return timeOrigin;
    }
    /**
     * Returns an hrtime calculated via performance component.
     * @param performanceNow
     */
    function hrTime(performanceNow) {
      var timeOrigin = millisToHrTime(getTimeOrigin());
      var now = millisToHrTime(typeof performanceNow === 'number' ? performanceNow : otperformance.now());
      return addHrTimes(timeOrigin, now);
    }
    /**
     * Returns a duration of two hrTime.
     * @param startTime
     * @param endTime
     */
    function hrTimeDuration(startTime, endTime) {
      var seconds = endTime[0] - startTime[0];
      var nanos = endTime[1] - startTime[1];
      // overflow
      if (nanos < 0) {
        seconds -= 1;
        // negate
        nanos += SECOND_TO_NANOSECONDS;
      }
      return [seconds, nanos];
    }
    /**
     * Convert hrTime to nanoseconds.
     * @param time
     */
    function hrTimeToNanoseconds(time) {
      return time[0] * SECOND_TO_NANOSECONDS + time[1];
    }
    /**
     * check if time is HrTime
     * @param value
     */
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] === 'number' && typeof value[1] === 'number';
    }
    /**
     * check if input value is a correct types.TimeInput
     * @param value
     */
    function isTimeInput(value) {
      return isTimeInputHrTime(value) || typeof value === 'number' || value instanceof Date;
    }
    /**
     * Given 2 HrTime formatted times, return their sum as an HrTime.
     */
    function addHrTimes(time1, time2) {
      var out = [time1[0] + time2[0], time1[1] + time2[1]];
      // Nanoseconds
      if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
      }
      return out;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var ExportResultCode;
    (function (ExportResultCode) {
      ExportResultCode[ExportResultCode["SUCCESS"] = 0] = "SUCCESS";
      ExportResultCode[ExportResultCode["FAILED"] = 1] = "FAILED";
    })(ExportResultCode || (ExportResultCode = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __values$3 = undefined && undefined.__values || function (o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function () {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    /** Combines multiple propagators into a single propagator. */
    var CompositePropagator = /** @class */function () {
      /**
       * Construct a composite propagator from a list of propagators.
       *
       * @param [config] Configuration object for composite propagator
       */
      function CompositePropagator(config) {
        if (config === void 0) {
          config = {};
        }
        var _a;
        this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [];
        this._fields = Array.from(new Set(this._propagators
        // older propagators may not have fields function, null check to be sure
        .map(function (p) {
          return typeof p.fields === 'function' ? p.fields() : [];
        }).reduce(function (x, y) {
          return x.concat(y);
        }, [])));
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same carrier key, the propagator later in the list
       * will "win".
       *
       * @param context Context to inject
       * @param carrier Carrier into which context will be injected
       */
      CompositePropagator.prototype.inject = function (context, carrier, setter) {
        var e_1, _a;
        try {
          for (var _b = __values$3(this._propagators), _c = _b.next(); !_c.done; _c = _b.next()) {
            var propagator = _c.value;
            try {
              propagator.inject(context, carrier, setter);
            } catch (err) {
              diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
            }
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      };
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same context key, the propagator later in the list
       * will "win".
       *
       * @param context Context to add values to
       * @param carrier Carrier from which to extract context
       */
      CompositePropagator.prototype.extract = function (context, carrier, getter) {
        return this._propagators.reduce(function (ctx, propagator) {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
          }
          return ctx;
        }, context);
      };
      CompositePropagator.prototype.fields = function () {
        // return a new array so our fields cannot be modified
        return this._fields.slice();
      };
      return CompositePropagator;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';
    var VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
    var VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
    var VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
    var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
    /**
     * Key is opaque string up to 256 characters printable. It MUST begin with a
     * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,
     * underscores _, dashes -, asterisks *, and forward slashes /.
     * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the
     * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.
     * see https://www.w3.org/TR/trace-context/#key
     */
    function validateKey(key) {
      return VALID_KEY_REGEX.test(key);
    }
    /**
     * Value is opaque string up to 256 characters printable ASCII RFC0020
     * characters (i.e., the range 0x20 to 0x7E) except comma , and =.
     */
    function validateValue(value) {
      return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var MAX_TRACE_STATE_ITEMS = 32;
    var MAX_TRACE_STATE_LEN = 512;
    var LIST_MEMBERS_SEPARATOR = ',';
    var LIST_MEMBER_KEY_VALUE_SPLITTER = '=';
    /**
     * TraceState must be a class and not a simple object type because of the spec
     * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).
     *
     * Here is the list of allowed mutations:
     * - New key-value pair should be added into the beginning of the list
     * - The value of any key can be updated. Modified keys MUST be moved to the
     * beginning of the list.
     */
    var TraceState = /** @class */function () {
      function TraceState(rawTraceState) {
        this._internalState = new Map();
        if (rawTraceState) this._parse(rawTraceState);
      }
      TraceState.prototype.set = function (key, value) {
        // TODO: Benchmark the different approaches(map vs list) and
        // use the faster one.
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      };
      TraceState.prototype.unset = function (key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      };
      TraceState.prototype.get = function (key) {
        return this._internalState.get(key);
      };
      TraceState.prototype.serialize = function () {
        var _this = this;
        return this._keys().reduce(function (agg, key) {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      };
      TraceState.prototype._parse = function (rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning
        .reduce(function (agg, part) {
          var listMember = part.trim(); // Optional Whitespace (OWS) handling
          var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            var key = listMember.slice(0, i);
            var value = listMember.slice(i + 1, part.length);
            if (validateKey(key) && validateValue(value)) {
              agg.set(key, value);
            }
          }
          return agg;
        }, new Map());
        // Because of the reverse() requirement, trunc must be done after map is created
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse() // Use reverse same as original tracestate parse chain
          .slice(0, MAX_TRACE_STATE_ITEMS));
        }
      };
      TraceState.prototype._keys = function () {
        return Array.from(this._internalState.keys()).reverse();
      };
      TraceState.prototype._clone = function () {
        var traceState = new TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      };
      return TraceState;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var TRACE_PARENT_HEADER = 'traceparent';
    var TRACE_STATE_HEADER = 'tracestate';
    var VERSION$1 = '00';
    var VERSION_PART = '(?!ff)[\\da-f]{2}';
    var TRACE_ID_PART = '(?![0]{32})[\\da-f]{32}';
    var PARENT_ID_PART = '(?![0]{16})[\\da-f]{16}';
    var FLAGS_PART = '[\\da-f]{2}';
    var TRACE_PARENT_REGEX = new RegExp("^\\s?(" + VERSION_PART + ")-(" + TRACE_ID_PART + ")-(" + PARENT_ID_PART + ")-(" + FLAGS_PART + ")(-.*)?\\s?$");
    /**
     * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}
     * @param traceParent - A meta property that comes from server.
     *     It should be dynamically generated server side to have the server's request trace Id,
     *     a parent span Id that was set on the server's request span,
     *     and the trace flags to indicate the server's sampling decision
     *     (01 = sampled, 00 = not sampled).
     *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'
     *     For more information see {@link https://www.w3.org/TR/trace-context/}
     */
    function parseTraceParent(traceParent) {
      var match = TRACE_PARENT_REGEX.exec(traceParent);
      if (!match) return null;
      // According to the specification the implementation should be compatible
      // with future versions. If there are more parts, we only reject it if it's using version 00
      // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent
      if (match[1] === '00' && match[5]) return null;
      return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16)
      };
    }
    /**
     * Propagates {@link SpanContext} through Trace Context format propagation.
     *
     * Based on the Trace Context specification:
     * https://www.w3.org/TR/trace-context/
     */
    var W3CTraceContextPropagator = /** @class */function () {
      function W3CTraceContextPropagator() {}
      W3CTraceContextPropagator.prototype.inject = function (context, carrier, setter) {
        var spanContext = trace.getSpanContext(context);
        if (!spanContext || isTracingSuppressed(context) || !isSpanContextValid(spanContext)) return;
        var traceParent = VERSION$1 + "-" + spanContext.traceId + "-" + spanContext.spanId + "-0" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);
        setter.set(carrier, TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
          setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
      };
      W3CTraceContextPropagator.prototype.extract = function (context, carrier, getter) {
        var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);
        if (!traceParentHeader) return context;
        var traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== 'string') return context;
        var spanContext = parseTraceParent(traceParent);
        if (!spanContext) return context;
        spanContext.isRemote = true;
        var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);
        if (traceStateHeader) {
          // If more than one `tracestate` header is found, we merge them into a
          // single header.
          var state = Array.isArray(traceStateHeader) ? traceStateHeader.join(',') : traceStateHeader;
          spanContext.traceState = new TraceState(typeof state === 'string' ? state : undefined);
        }
        return trace.setSpanContext(context, spanContext);
      };
      W3CTraceContextPropagator.prototype.fields = function () {
        return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];
      };
      return W3CTraceContextPropagator;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /* eslint-disable @typescript-eslint/no-explicit-any */
    /**
     * based on lodash in order to support esm builds without esModuleInterop.
     * lodash is using MIT License.
     **/
    var objectTag = '[object Object]';
    var nullTag = '[object Null]';
    var undefinedTag = '[object Undefined]';
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    var objectCtorString = funcToString.call(Object);
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
    var nativeObjectToString = objectProto.toString;
    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }
    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
    }
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }
    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];
      var unmasked = false;
      try {
        value[symToStringTag] = undefined;
        unmasked = true;
      } catch (e) {
        // silence
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /* eslint-disable @typescript-eslint/no-explicit-any */
    var MAX_LEVEL = 20;
    /**
     * Merges objects together
     * @param args - objects / values to be merged
     */
    function merge() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var result = args.shift();
      var objects = new WeakMap();
      while (args.length > 0) {
        result = mergeTwoObjects(result, args.shift(), 0, objects);
      }
      return result;
    }
    function takeValue(value) {
      if (isArray(value)) {
        return value.slice();
      }
      return value;
    }
    /**
     * Merges two objects
     * @param one - first object
     * @param two - second object
     * @param level - current deep level
     * @param objects - objects holder that has been already referenced - to prevent
     * cyclic dependency
     */
    function mergeTwoObjects(one, two, level, objects) {
      if (level === void 0) {
        level = 0;
      }
      var result;
      if (level > MAX_LEVEL) {
        return undefined;
      }
      level++;
      if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
        result = takeValue(two);
      } else if (isArray(one)) {
        result = one.slice();
        if (isArray(two)) {
          for (var i = 0, j = two.length; i < j; i++) {
            result.push(takeValue(two[i]));
          }
        } else if (isObject(two)) {
          var keys = Object.keys(two);
          for (var i = 0, j = keys.length; i < j; i++) {
            var key = keys[i];
            result[key] = takeValue(two[key]);
          }
        }
      } else if (isObject(one)) {
        if (isObject(two)) {
          if (!shouldMerge(one, two)) {
            return two;
          }
          result = Object.assign({}, one);
          var keys = Object.keys(two);
          for (var i = 0, j = keys.length; i < j; i++) {
            var key = keys[i];
            var twoValue = two[key];
            if (isPrimitive(twoValue)) {
              if (typeof twoValue === 'undefined') {
                delete result[key];
              } else {
                // result[key] = takeValue(twoValue);
                result[key] = twoValue;
              }
            } else {
              var obj1 = result[key];
              var obj2 = twoValue;
              if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
                delete result[key];
              } else {
                if (isObject(obj1) && isObject(obj2)) {
                  var arr1 = objects.get(obj1) || [];
                  var arr2 = objects.get(obj2) || [];
                  arr1.push({
                    obj: one,
                    key: key
                  });
                  arr2.push({
                    obj: two,
                    key: key
                  });
                  objects.set(obj1, arr1);
                  objects.set(obj2, arr2);
                }
                result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
              }
            }
          }
        } else {
          result = two;
        }
      }
      return result;
    }
    /**
     * Function to check if object has been already reference
     * @param obj
     * @param key
     * @param objects
     */
    function wasObjectReferenced(obj, key, objects) {
      var arr = objects.get(obj[key]) || [];
      for (var i = 0, j = arr.length; i < j; i++) {
        var info = arr[i];
        if (info.key === key && info.obj === obj) {
          return true;
        }
      }
      return false;
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function isFunction(value) {
      return typeof value === 'function';
    }
    function isObject(value) {
      return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === 'object';
    }
    function isPrimitive(value) {
      return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || typeof value === 'undefined' || value instanceof Date || value instanceof RegExp || value === null;
    }
    function shouldMerge(one, two) {
      if (!isPlainObject(one) || !isPlainObject(two)) {
        return false;
      }
      return true;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var Deferred = /** @class */function () {
      function Deferred() {
        var _this = this;
        this._promise = new Promise(function (resolve, reject) {
          _this._resolve = resolve;
          _this._reject = reject;
        });
      }
      Object.defineProperty(Deferred.prototype, "promise", {
        get: function () {
          return this._promise;
        },
        enumerable: false,
        configurable: true
      });
      Deferred.prototype.resolve = function (val) {
        this._resolve(val);
      };
      Deferred.prototype.reject = function (err) {
        this._reject(err);
      };
      return Deferred;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __read$7 = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray$2 = undefined && undefined.__spreadArray || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    /**
     * Bind the callback and only invoke the callback once regardless how many times `BindOnceFuture.call` is invoked.
     */
    var BindOnceFuture = /** @class */function () {
      function BindOnceFuture(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new Deferred();
      }
      Object.defineProperty(BindOnceFuture.prototype, "isCalled", {
        get: function () {
          return this._isCalled;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BindOnceFuture.prototype, "promise", {
        get: function () {
          return this._deferred.promise;
        },
        enumerable: false,
        configurable: true
      });
      BindOnceFuture.prototype.call = function () {
        var _a;
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!this._isCalled) {
          this._isCalled = true;
          try {
            Promise.resolve((_a = this._callback).call.apply(_a, __spreadArray$2([this._that], __read$7(args), false))).then(function (val) {
              return _this._deferred.resolve(val);
            }, function (err) {
              return _this._deferred.reject(err);
            });
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      };
      return BindOnceFuture;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function defaultServiceName() {
      return 'unknown_service';
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __assign$2 = undefined && undefined.__assign || function () {
      __assign$2 = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign$2.apply(this, arguments);
    };
    var __awaiter$2 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator$2 = undefined && undefined.__generator || function (thisArg, body) {
      var _ = {
          label: 0,
          sent: function () {
            if (t[0] & 1) throw t[1];
            return t[1];
          },
          trys: [],
          ops: []
        },
        f,
        y,
        t,
        g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;
      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    var __read$6 = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    /**
     * A Resource describes the entity for which a signals (metrics or trace) are
     * collected.
     */
    var Resource = /** @class */function () {
      function Resource(
      /**
       * A dictionary of attributes with string keys and values that provide
       * information about the entity as numbers, strings or booleans
       * TODO: Consider to add check/validation on attributes.
       */
      attributes, asyncAttributesPromise) {
        var _this = this;
        var _a;
        this._attributes = attributes;
        this.asyncAttributesPending = asyncAttributesPromise != null;
        this._syncAttributes = (_a = this._attributes) !== null && _a !== void 0 ? _a : {};
        this._asyncAttributesPromise = asyncAttributesPromise === null || asyncAttributesPromise === void 0 ? void 0 : asyncAttributesPromise.then(function (asyncAttributes) {
          _this._attributes = Object.assign({}, _this._attributes, asyncAttributes);
          _this.asyncAttributesPending = false;
          return asyncAttributes;
        }, function (err) {
          diag.debug("a resource's async attributes promise rejected: %s", err);
          _this.asyncAttributesPending = false;
          return {};
        });
      }
      /**
       * Returns an empty Resource
       */
      Resource.empty = function () {
        return Resource.EMPTY;
      };
      /**
       * Returns a Resource that identifies the SDK in use.
       */
      Resource.default = function () {
        var _a;
        return new Resource((_a = {}, _a[SEMRESATTRS_SERVICE_NAME] = defaultServiceName(), _a[SEMRESATTRS_TELEMETRY_SDK_LANGUAGE] = SDK_INFO[SEMRESATTRS_TELEMETRY_SDK_LANGUAGE], _a[SEMRESATTRS_TELEMETRY_SDK_NAME] = SDK_INFO[SEMRESATTRS_TELEMETRY_SDK_NAME], _a[SEMRESATTRS_TELEMETRY_SDK_VERSION] = SDK_INFO[SEMRESATTRS_TELEMETRY_SDK_VERSION], _a));
      };
      Object.defineProperty(Resource.prototype, "attributes", {
        get: function () {
          var _a;
          if (this.asyncAttributesPending) {
            diag.error('Accessing resource attributes before async attributes settled');
          }
          return (_a = this._attributes) !== null && _a !== void 0 ? _a : {};
        },
        enumerable: false,
        configurable: true
      });
      /**
       * Returns a promise that will never be rejected. Resolves when all async attributes have finished being added to
       * this Resource's attributes. This is useful in exporters to block until resource detection
       * has finished.
       */
      Resource.prototype.waitForAsyncAttributes = function () {
        return __awaiter$2(this, void 0, void 0, function () {
          return __generator$2(this, function (_a) {
            switch (_a.label) {
              case 0:
                if (!this.asyncAttributesPending) return [3 /*break*/, 2];
                return [4 /*yield*/, this._asyncAttributesPromise];
              case 1:
                _a.sent();
                _a.label = 2;
              case 2:
                return [2 /*return*/];
            }
          });
        });
      };
      /**
       * Returns a new, merged {@link Resource} by merging the current Resource
       * with the other Resource. In case of a collision, other Resource takes
       * precedence.
       *
       * @param other the Resource that will be merged with this.
       * @returns the newly merged Resource.
       */
      Resource.prototype.merge = function (other) {
        var _this = this;
        var _a;
        if (!other) return this;
        // SpanAttributes from other resource overwrite attributes from this resource.
        var mergedSyncAttributes = __assign$2(__assign$2({}, this._syncAttributes), (_a = other._syncAttributes) !== null && _a !== void 0 ? _a : other.attributes);
        if (!this._asyncAttributesPromise && !other._asyncAttributesPromise) {
          return new Resource(mergedSyncAttributes);
        }
        var mergedAttributesPromise = Promise.all([this._asyncAttributesPromise, other._asyncAttributesPromise]).then(function (_a) {
          var _b;
          var _c = __read$6(_a, 2),
            thisAsyncAttributes = _c[0],
            otherAsyncAttributes = _c[1];
          return __assign$2(__assign$2(__assign$2(__assign$2({}, _this._syncAttributes), thisAsyncAttributes), (_b = other._syncAttributes) !== null && _b !== void 0 ? _b : other.attributes), otherAsyncAttributes);
        });
        return new Resource(mergedSyncAttributes, mergedAttributesPromise);
      };
      Resource.EMPTY = new Resource({});
      return Resource;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var isPromiseLike = function (val) {
      return val !== null && typeof val === 'object' && typeof val.then === 'function';
    };

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __awaiter$1 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator$1 = undefined && undefined.__generator || function (thisArg, body) {
      var _ = {
          label: 0,
          sent: function () {
            if (t[0] & 1) throw t[1];
            return t[1];
          },
          trys: [],
          ops: []
        },
        f,
        y,
        t,
        g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;
      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    /**
     * Runs all resource detectors synchronously, merging their results. In case of attribute collision later resources will take precedence.
     *
     * @param config Configuration for resource detection
     */
    var detectResourcesSync = function (config) {
      var _a;
      if (config === void 0) {
        config = {};
      }
      var resources = ((_a = config.detectors) !== null && _a !== void 0 ? _a : []).map(function (d) {
        try {
          var resourceOrPromise_1 = d.detect(config);
          var resource_1;
          if (isPromiseLike(resourceOrPromise_1)) {
            var createPromise = function () {
              return __awaiter$1(void 0, void 0, void 0, function () {
                var resolvedResource;
                return __generator$1(this, function (_a) {
                  switch (_a.label) {
                    case 0:
                      return [4 /*yield*/, resourceOrPromise_1];
                    case 1:
                      resolvedResource = _a.sent();
                      return [2 /*return*/, resolvedResource.attributes];
                  }
                });
              });
            };
            resource_1 = new Resource({}, createPromise());
          } else {
            resource_1 = resourceOrPromise_1;
          }
          if (resource_1.waitForAsyncAttributes) {
            void resource_1.waitForAsyncAttributes().then(function () {
              return diag.debug(d.constructor.name + " found resource.", resource_1);
            });
          } else {
            diag.debug(d.constructor.name + " found resource.", resource_1);
          }
          return resource_1;
        } catch (e) {
          diag.error(d.constructor.name + " failed: " + e.message);
          return Resource.empty();
        }
      });
      var mergedResources = resources.reduce(function (acc, resource) {
        return acc.merge(resource);
      }, Resource.empty());
      if (mergedResources.waitForAsyncAttributes) {
        void mergedResources.waitForAsyncAttributes().then(function () {
          // Future check if verbose logging is enabled issue #1903
          logResources(resources);
        });
      }
      return mergedResources;
    };
    /**
     * Writes debug information about the detected resources to the logger defined in the resource detection config, if one is provided.
     *
     * @param resources The array of {@link Resource} that should be logged. Empty entries will be ignored.
     */
    var logResources = function (resources) {
      resources.forEach(function (resource) {
        // Print only populated resources
        if (Object.keys(resource.attributes).length > 0) {
          var resourceDebugString = JSON.stringify(resource.attributes, null, 4);
          diag.verbose(resourceDebugString);
        }
      });
    };

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Event name definitions
    var ExceptionEventName = 'exception';

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __values$2 = undefined && undefined.__values || function (o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function () {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read$5 = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray$1 = undefined && undefined.__spreadArray || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    /**
     * This class represents a span.
     */
    var Span = /** @class */function () {
      /**
       * Constructs a new Span instance.
       *
       * @deprecated calling Span constructor directly is not supported. Please use tracer.startSpan.
       * */
      function Span(parentTracer, context, spanName, spanContext, kind, parentSpanId, links, startTime, _deprecatedClock,
      // keeping this argument even though it is unused to ensure backwards compatibility
      attributes) {
        if (links === void 0) {
          links = [];
        }
        this.attributes = {};
        this.links = [];
        this.events = [];
        this._droppedAttributesCount = 0;
        this._droppedEventsCount = 0;
        this._droppedLinksCount = 0;
        this.status = {
          code: SpanStatusCode.UNSET
        };
        this.endTime = [0, 0];
        this._ended = false;
        this._duration = [-1, -1];
        this.name = spanName;
        this._spanContext = spanContext;
        this.parentSpanId = parentSpanId;
        this.kind = kind;
        this.links = links;
        var now = Date.now();
        this._performanceStartTime = otperformance.now();
        this._performanceOffset = now - (this._performanceStartTime + getTimeOrigin());
        this._startTimeProvided = startTime != null;
        this.startTime = this._getTime(startTime !== null && startTime !== void 0 ? startTime : now);
        this.resource = parentTracer.resource;
        this.instrumentationLibrary = parentTracer.instrumentationLibrary;
        this._spanLimits = parentTracer.getSpanLimits();
        this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;
        if (attributes != null) {
          this.setAttributes(attributes);
        }
        this._spanProcessor = parentTracer.getActiveSpanProcessor();
        this._spanProcessor.onStart(this, context);
      }
      Span.prototype.spanContext = function () {
        return this._spanContext;
      };
      Span.prototype.setAttribute = function (key, value) {
        if (value == null || this._isSpanEnded()) return this;
        if (key.length === 0) {
          diag.warn("Invalid attribute key: " + key);
          return this;
        }
        if (!isAttributeValue(value)) {
          diag.warn("Invalid attribute value set for key: " + key);
          return this;
        }
        if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
          this._droppedAttributesCount++;
          return this;
        }
        this.attributes[key] = this._truncateToSize(value);
        return this;
      };
      Span.prototype.setAttributes = function (attributes) {
        var e_1, _a;
        try {
          for (var _b = __values$2(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read$5(_c.value, 2),
              k = _d[0],
              v = _d[1];
            this.setAttribute(k, v);
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return this;
      };
      /**
       *
       * @param name Span Name
       * @param [attributesOrStartTime] Span attributes or start time
       *     if type is {@type TimeInput} and 3rd param is undefined
       * @param [timeStamp] Specified time stamp for the event
       */
      Span.prototype.addEvent = function (name, attributesOrStartTime, timeStamp) {
        if (this._isSpanEnded()) return this;
        if (this._spanLimits.eventCountLimit === 0) {
          diag.warn('No events allowed.');
          this._droppedEventsCount++;
          return this;
        }
        if (this.events.length >= this._spanLimits.eventCountLimit) {
          if (this._droppedEventsCount === 0) {
            diag.debug('Dropping extra events.');
          }
          this.events.shift();
          this._droppedEventsCount++;
        }
        if (isTimeInput(attributesOrStartTime)) {
          if (!isTimeInput(timeStamp)) {
            timeStamp = attributesOrStartTime;
          }
          attributesOrStartTime = undefined;
        }
        var attributes = sanitizeAttributes(attributesOrStartTime);
        this.events.push({
          name: name,
          attributes: attributes,
          time: this._getTime(timeStamp),
          droppedAttributesCount: 0
        });
        return this;
      };
      Span.prototype.addLink = function (link) {
        this.links.push(link);
        return this;
      };
      Span.prototype.addLinks = function (links) {
        var _a;
        (_a = this.links).push.apply(_a, __spreadArray$1([], __read$5(links), false));
        return this;
      };
      Span.prototype.setStatus = function (status) {
        if (this._isSpanEnded()) return this;
        this.status = status;
        return this;
      };
      Span.prototype.updateName = function (name) {
        if (this._isSpanEnded()) return this;
        this.name = name;
        return this;
      };
      Span.prototype.end = function (endTime) {
        if (this._isSpanEnded()) {
          diag.error(this.name + " " + this._spanContext.traceId + "-" + this._spanContext.spanId + " - You can only call end() on a span once.");
          return;
        }
        this._ended = true;
        this.endTime = this._getTime(endTime);
        this._duration = hrTimeDuration(this.startTime, this.endTime);
        if (this._duration[0] < 0) {
          diag.warn('Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.', this.startTime, this.endTime);
          this.endTime = this.startTime.slice();
          this._duration = [0, 0];
        }
        if (this._droppedEventsCount > 0) {
          diag.warn("Dropped " + this._droppedEventsCount + " events because eventCountLimit reached");
        }
        this._spanProcessor.onEnd(this);
      };
      Span.prototype._getTime = function (inp) {
        if (typeof inp === 'number' && inp < otperformance.now()) {
          // must be a performance timestamp
          // apply correction and convert to hrtime
          return hrTime(inp + this._performanceOffset);
        }
        if (typeof inp === 'number') {
          return millisToHrTime(inp);
        }
        if (inp instanceof Date) {
          return millisToHrTime(inp.getTime());
        }
        if (isTimeInputHrTime(inp)) {
          return inp;
        }
        if (this._startTimeProvided) {
          // if user provided a time for the start manually
          // we can't use duration to calculate event/end times
          return millisToHrTime(Date.now());
        }
        var msDuration = otperformance.now() - this._performanceStartTime;
        return addHrTimes(this.startTime, millisToHrTime(msDuration));
      };
      Span.prototype.isRecording = function () {
        return this._ended === false;
      };
      Span.prototype.recordException = function (exception, time) {
        var attributes = {};
        if (typeof exception === 'string') {
          attributes[SEMATTRS_EXCEPTION_MESSAGE] = exception;
        } else if (exception) {
          if (exception.code) {
            attributes[SEMATTRS_EXCEPTION_TYPE] = exception.code.toString();
          } else if (exception.name) {
            attributes[SEMATTRS_EXCEPTION_TYPE] = exception.name;
          }
          if (exception.message) {
            attributes[SEMATTRS_EXCEPTION_MESSAGE] = exception.message;
          }
          if (exception.stack) {
            attributes[SEMATTRS_EXCEPTION_STACKTRACE] = exception.stack;
          }
        }
        // these are minimum requirements from spec
        if (attributes[SEMATTRS_EXCEPTION_TYPE] || attributes[SEMATTRS_EXCEPTION_MESSAGE]) {
          this.addEvent(ExceptionEventName, attributes, time);
        } else {
          diag.warn("Failed to record an exception " + exception);
        }
      };
      Object.defineProperty(Span.prototype, "duration", {
        get: function () {
          return this._duration;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Span.prototype, "ended", {
        get: function () {
          return this._ended;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Span.prototype, "droppedAttributesCount", {
        get: function () {
          return this._droppedAttributesCount;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Span.prototype, "droppedEventsCount", {
        get: function () {
          return this._droppedEventsCount;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Span.prototype, "droppedLinksCount", {
        get: function () {
          return this._droppedLinksCount;
        },
        enumerable: false,
        configurable: true
      });
      Span.prototype._isSpanEnded = function () {
        if (this._ended) {
          diag.warn("Can not execute the operation on ended Span {traceId: " + this._spanContext.traceId + ", spanId: " + this._spanContext.spanId + "}");
        }
        return this._ended;
      };
      // Utility function to truncate given value within size
      // for value type of string, will truncate to given limit
      // for type of non-string, will return same value
      Span.prototype._truncateToLimitUtil = function (value, limit) {
        if (value.length <= limit) {
          return value;
        }
        return value.substr(0, limit);
      };
      /**
       * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then
       * return string with truncated to {@code attributeValueLengthLimit} characters
       *
       * If the given attribute value is array of strings then
       * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters
       *
       * Otherwise return same Attribute {@code value}
       *
       * @param value Attribute value
       * @returns truncated attribute value if required, otherwise same value
       */
      Span.prototype._truncateToSize = function (value) {
        var _this = this;
        var limit = this._attributeValueLengthLimit;
        // Check limit
        if (limit <= 0) {
          // Negative values are invalid, so do not truncate
          diag.warn("Attribute value limit must be positive, got " + limit);
          return value;
        }
        // String
        if (typeof value === 'string') {
          return this._truncateToLimitUtil(value, limit);
        }
        // Array of strings
        if (Array.isArray(value)) {
          return value.map(function (val) {
            return typeof val === 'string' ? _this._truncateToLimitUtil(val, limit) : val;
          });
        }
        // Other types, no need to apply value length limit
        return value;
      };
      return Span;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * A sampling decision that determines how a {@link Span} will be recorded
     * and collected.
     */
    var SamplingDecision;
    (function (SamplingDecision) {
      /**
       * `Span.isRecording() === false`, span will not be recorded and all events
       * and attributes will be dropped.
       */
      SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
      /**
       * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
       * MUST NOT be set.
       */
      SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
      /**
       * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
       * MUST be set.
       */
      SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision || (SamplingDecision = {}));

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /** Sampler that samples no traces. */
    var AlwaysOffSampler = /** @class */function () {
      function AlwaysOffSampler() {}
      AlwaysOffSampler.prototype.shouldSample = function () {
        return {
          decision: SamplingDecision.NOT_RECORD
        };
      };
      AlwaysOffSampler.prototype.toString = function () {
        return 'AlwaysOffSampler';
      };
      return AlwaysOffSampler;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /** Sampler that samples all traces. */
    var AlwaysOnSampler = /** @class */function () {
      function AlwaysOnSampler() {}
      AlwaysOnSampler.prototype.shouldSample = function () {
        return {
          decision: SamplingDecision.RECORD_AND_SAMPLED
        };
      };
      AlwaysOnSampler.prototype.toString = function () {
        return 'AlwaysOnSampler';
      };
      return AlwaysOnSampler;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * A composite sampler that either respects the parent span's sampling decision
     * or delegates to `delegateSampler` for root spans.
     */
    var ParentBasedSampler = /** @class */function () {
      function ParentBasedSampler(config) {
        var _a, _b, _c, _d;
        this._root = config.root;
        if (!this._root) {
          globalErrorHandler(new Error('ParentBasedSampler must have a root sampler configured'));
          this._root = new AlwaysOnSampler();
        }
        this._remoteParentSampled = (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new AlwaysOnSampler();
        this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler();
        this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler();
        this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler();
      }
      ParentBasedSampler.prototype.shouldSample = function (context, traceId, spanName, spanKind, attributes, links) {
        var parentContext = trace.getSpanContext(context);
        if (!parentContext || !isSpanContextValid(parentContext)) {
          return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      };
      ParentBasedSampler.prototype.toString = function () {
        return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
      };
      return ParentBasedSampler;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /** Sampler that samples a given fraction of traces based of trace id deterministically. */
    var TraceIdRatioBasedSampler = /** @class */function () {
      function TraceIdRatioBasedSampler(_ratio) {
        if (_ratio === void 0) {
          _ratio = 0;
        }
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 0xffffffff);
      }
      TraceIdRatioBasedSampler.prototype.shouldSample = function (context, traceId) {
        return {
          decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound ? SamplingDecision.RECORD_AND_SAMPLED : SamplingDecision.NOT_RECORD
        };
      };
      TraceIdRatioBasedSampler.prototype.toString = function () {
        return "TraceIdRatioBased{" + this._ratio + "}";
      };
      TraceIdRatioBasedSampler.prototype._normalize = function (ratio) {
        if (typeof ratio !== 'number' || isNaN(ratio)) return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      };
      TraceIdRatioBasedSampler.prototype._accumulate = function (traceId) {
        var accumulation = 0;
        for (var i = 0; i < traceId.length / 8; i++) {
          var pos = i * 8;
          var part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      };
      return TraceIdRatioBasedSampler;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var env = getEnv();
    var FALLBACK_OTEL_TRACES_SAMPLER = TracesSamplerValues.AlwaysOn;
    var DEFAULT_RATIO = 1;
    /**
     * Load default configuration. For fields with primitive values, any user-provided
     * value will override the corresponding default value. For fields with
     * non-primitive values (like `spanLimits`), the user-provided value will be
     * used to extend the default value.
     */
    // object needs to be wrapped in this function and called when needed otherwise
    // envs are parsed before tests are ran - causes tests using these envs to fail
    function loadDefaultConfig() {
      return {
        sampler: buildSamplerFromEnv(env),
        forceFlushTimeoutMillis: 30000,
        generalLimits: {
          attributeValueLengthLimit: getEnv().OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
          attributeCountLimit: getEnv().OTEL_ATTRIBUTE_COUNT_LIMIT
        },
        spanLimits: {
          attributeValueLengthLimit: getEnv().OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
          attributeCountLimit: getEnv().OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
          linkCountLimit: getEnv().OTEL_SPAN_LINK_COUNT_LIMIT,
          eventCountLimit: getEnv().OTEL_SPAN_EVENT_COUNT_LIMIT,
          attributePerEventCountLimit: getEnv().OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
          attributePerLinkCountLimit: getEnv().OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT
        }
      };
    }
    /**
     * Based on environment, builds a sampler, complies with specification.
     * @param environment optional, by default uses getEnv(), but allows passing a value to reuse parsed environment
     */
    function buildSamplerFromEnv(environment) {
      if (environment === void 0) {
        environment = getEnv();
      }
      switch (environment.OTEL_TRACES_SAMPLER) {
        case TracesSamplerValues.AlwaysOn:
          return new AlwaysOnSampler();
        case TracesSamplerValues.AlwaysOff:
          return new AlwaysOffSampler();
        case TracesSamplerValues.ParentBasedAlwaysOn:
          return new ParentBasedSampler({
            root: new AlwaysOnSampler()
          });
        case TracesSamplerValues.ParentBasedAlwaysOff:
          return new ParentBasedSampler({
            root: new AlwaysOffSampler()
          });
        case TracesSamplerValues.TraceIdRatio:
          return new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment));
        case TracesSamplerValues.ParentBasedTraceIdRatio:
          return new ParentBasedSampler({
            root: new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment))
          });
        default:
          diag.error("OTEL_TRACES_SAMPLER value \"" + environment.OTEL_TRACES_SAMPLER + " invalid, defaulting to " + FALLBACK_OTEL_TRACES_SAMPLER + "\".");
          return new AlwaysOnSampler();
      }
    }
    function getSamplerProbabilityFromEnv(environment) {
      if (environment.OTEL_TRACES_SAMPLER_ARG === undefined || environment.OTEL_TRACES_SAMPLER_ARG === '') {
        diag.error("OTEL_TRACES_SAMPLER_ARG is blank, defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
      }
      var probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);
      if (isNaN(probability)) {
        diag.error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is invalid, defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
      }
      if (probability < 0 || probability > 1) {
        diag.error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is out of range ([0..1]), defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
      }
      return probability;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Function to merge Default configuration (as specified in './config') with
     * user provided configurations.
     */
    function mergeConfig(userConfig) {
      var perInstanceDefaults = {
        sampler: buildSamplerFromEnv()
      };
      var DEFAULT_CONFIG = loadDefaultConfig();
      var target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);
      target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});
      target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});
      return target;
    }
    /**
     * When general limits are provided and model specific limits are not,
     * configures the model specific limits by using the values from the general ones.
     * @param userConfig User provided tracer configuration
     */
    function reconfigureLimits(userConfig) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      var spanLimits = Object.assign({}, userConfig.spanLimits);
      var parsedEnvConfig = getEnvWithoutDefaults();
      /**
       * Reassign span attribute count limit to use first non null value defined by user or use default value
       */
      spanLimits.attributeCountLimit = (_f = (_e = (_d = (_b = (_a = userConfig.spanLimits) === null || _a === void 0 ? void 0 : _a.attributeCountLimit) !== null && _b !== void 0 ? _b : (_c = userConfig.generalLimits) === null || _c === void 0 ? void 0 : _c.attributeCountLimit) !== null && _d !== void 0 ? _d : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && _e !== void 0 ? _e : parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && _f !== void 0 ? _f : DEFAULT_ATTRIBUTE_COUNT_LIMIT;
      /**
       * Reassign span attribute value length limit to use first non null value defined by user or use default value
       */
      spanLimits.attributeValueLengthLimit = (_m = (_l = (_k = (_h = (_g = userConfig.spanLimits) === null || _g === void 0 ? void 0 : _g.attributeValueLengthLimit) !== null && _h !== void 0 ? _h : (_j = userConfig.generalLimits) === null || _j === void 0 ? void 0 : _j.attributeValueLengthLimit) !== null && _k !== void 0 ? _k : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _l !== void 0 ? _l : parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _m !== void 0 ? _m : DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
      return Object.assign({}, userConfig, {
        spanLimits: spanLimits
      });
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Implementation of the {@link SpanProcessor} that batches spans exported by
     * the SDK then pushes them to the exporter pipeline.
     */
    var BatchSpanProcessorBase = /** @class */function () {
      function BatchSpanProcessorBase(_exporter, config) {
        this._exporter = _exporter;
        this._isExporting = false;
        this._finishedSpans = [];
        this._droppedSpansCount = 0;
        var env = getEnv();
        this._maxExportBatchSize = typeof (config === null || config === void 0 ? void 0 : config.maxExportBatchSize) === 'number' ? config.maxExportBatchSize : env.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;
        this._maxQueueSize = typeof (config === null || config === void 0 ? void 0 : config.maxQueueSize) === 'number' ? config.maxQueueSize : env.OTEL_BSP_MAX_QUEUE_SIZE;
        this._scheduledDelayMillis = typeof (config === null || config === void 0 ? void 0 : config.scheduledDelayMillis) === 'number' ? config.scheduledDelayMillis : env.OTEL_BSP_SCHEDULE_DELAY;
        this._exportTimeoutMillis = typeof (config === null || config === void 0 ? void 0 : config.exportTimeoutMillis) === 'number' ? config.exportTimeoutMillis : env.OTEL_BSP_EXPORT_TIMEOUT;
        this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
        if (this._maxExportBatchSize > this._maxQueueSize) {
          diag.warn('BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize');
          this._maxExportBatchSize = this._maxQueueSize;
        }
      }
      BatchSpanProcessorBase.prototype.forceFlush = function () {
        if (this._shutdownOnce.isCalled) {
          return this._shutdownOnce.promise;
        }
        return this._flushAll();
      };
      // does nothing.
      BatchSpanProcessorBase.prototype.onStart = function (_span, _parentContext) {};
      BatchSpanProcessorBase.prototype.onEnd = function (span) {
        if (this._shutdownOnce.isCalled) {
          return;
        }
        if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {
          return;
        }
        this._addToBuffer(span);
      };
      BatchSpanProcessorBase.prototype.shutdown = function () {
        return this._shutdownOnce.call();
      };
      BatchSpanProcessorBase.prototype._shutdown = function () {
        var _this = this;
        return Promise.resolve().then(function () {
          return _this.onShutdown();
        }).then(function () {
          return _this._flushAll();
        }).then(function () {
          return _this._exporter.shutdown();
        });
      };
      /** Add a span in the buffer. */
      BatchSpanProcessorBase.prototype._addToBuffer = function (span) {
        if (this._finishedSpans.length >= this._maxQueueSize) {
          // limit reached, drop span
          if (this._droppedSpansCount === 0) {
            diag.debug('maxQueueSize reached, dropping spans');
          }
          this._droppedSpansCount++;
          return;
        }
        if (this._droppedSpansCount > 0) {
          // some spans were dropped, log once with count of spans dropped
          diag.warn("Dropped " + this._droppedSpansCount + " spans because maxQueueSize reached");
          this._droppedSpansCount = 0;
        }
        this._finishedSpans.push(span);
        this._maybeStartTimer();
      };
      /**
       * Send all spans to the exporter respecting the batch size limit
       * This function is used only on forceFlush or shutdown,
       * for all other cases _flush should be used
       * */
      BatchSpanProcessorBase.prototype._flushAll = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
          var promises = [];
          // calculate number of batches
          var count = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);
          for (var i = 0, j = count; i < j; i++) {
            promises.push(_this._flushOneBatch());
          }
          Promise.all(promises).then(function () {
            resolve();
          }).catch(reject);
        });
      };
      BatchSpanProcessorBase.prototype._flushOneBatch = function () {
        var _this = this;
        this._clearTimer();
        if (this._finishedSpans.length === 0) {
          return Promise.resolve();
        }
        return new Promise(function (resolve, reject) {
          var timer = setTimeout(function () {
            // don't wait anymore for export, this way the next batch can start
            reject(new Error('Timeout'));
          }, _this._exportTimeoutMillis);
          // prevent downstream exporter calls from generating spans
          context.with(suppressTracing(context.active()), function () {
            // Reset the finished spans buffer here because the next invocations of the _flush method
            // could pass the same finished spans to the exporter if the buffer is cleared
            // outside the execution of this callback.
            var spans;
            if (_this._finishedSpans.length <= _this._maxExportBatchSize) {
              spans = _this._finishedSpans;
              _this._finishedSpans = [];
            } else {
              spans = _this._finishedSpans.splice(0, _this._maxExportBatchSize);
            }
            var doExport = function () {
              return _this._exporter.export(spans, function (result) {
                var _a;
                clearTimeout(timer);
                if (result.code === ExportResultCode.SUCCESS) {
                  resolve();
                } else {
                  reject((_a = result.error) !== null && _a !== void 0 ? _a : new Error('BatchSpanProcessor: span export failed'));
                }
              });
            };
            var pendingResources = null;
            for (var i = 0, len = spans.length; i < len; i++) {
              var span = spans[i];
              if (span.resource.asyncAttributesPending && span.resource.waitForAsyncAttributes) {
                pendingResources !== null && pendingResources !== void 0 ? pendingResources : pendingResources = [];
                pendingResources.push(span.resource.waitForAsyncAttributes());
              }
            }
            // Avoid scheduling a promise to make the behavior more predictable and easier to test
            if (pendingResources === null) {
              doExport();
            } else {
              Promise.all(pendingResources).then(doExport, function (err) {
                globalErrorHandler(err);
                reject(err);
              });
            }
          });
        });
      };
      BatchSpanProcessorBase.prototype._maybeStartTimer = function () {
        var _this = this;
        if (this._isExporting) return;
        var flush = function () {
          _this._isExporting = true;
          _this._flushOneBatch().finally(function () {
            _this._isExporting = false;
            if (_this._finishedSpans.length > 0) {
              _this._clearTimer();
              _this._maybeStartTimer();
            }
          }).catch(function (e) {
            _this._isExporting = false;
            globalErrorHandler(e);
          });
        };
        // we only wait if the queue doesn't have enough elements yet
        if (this._finishedSpans.length >= this._maxExportBatchSize) {
          return flush();
        }
        if (this._timer !== undefined) return;
        this._timer = setTimeout(function () {
          return flush();
        }, this._scheduledDelayMillis);
        unrefTimer(this._timer);
      };
      BatchSpanProcessorBase.prototype._clearTimer = function () {
        if (this._timer !== undefined) {
          clearTimeout(this._timer);
          this._timer = undefined;
        }
      };
      return BatchSpanProcessorBase;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __extends$4 = undefined && undefined.__extends || function () {
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var BatchSpanProcessor = /** @class */function (_super) {
      __extends$4(BatchSpanProcessor, _super);
      function BatchSpanProcessor(_exporter, config) {
        var _this = _super.call(this, _exporter, config) || this;
        _this.onInit(config);
        return _this;
      }
      BatchSpanProcessor.prototype.onInit = function (config) {
        var _this = this;
        if ((config === null || config === void 0 ? void 0 : config.disableAutoFlushOnDocumentHide) !== true && typeof document !== 'undefined') {
          this._visibilityChangeListener = function () {
            if (document.visibilityState === 'hidden') {
              void _this.forceFlush();
            }
          };
          this._pageHideListener = function () {
            void _this.forceFlush();
          };
          document.addEventListener('visibilitychange', this._visibilityChangeListener);
          // use 'pagehide' event as a fallback for Safari; see https://bugs.webkit.org/show_bug.cgi?id=116769
          document.addEventListener('pagehide', this._pageHideListener);
        }
      };
      BatchSpanProcessor.prototype.onShutdown = function () {
        if (typeof document !== 'undefined') {
          if (this._visibilityChangeListener) {
            document.removeEventListener('visibilitychange', this._visibilityChangeListener);
          }
          if (this._pageHideListener) {
            document.removeEventListener('pagehide', this._pageHideListener);
          }
        }
      };
      return BatchSpanProcessor;
    }(BatchSpanProcessorBase);

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var SPAN_ID_BYTES = 8;
    var TRACE_ID_BYTES = 16;
    var RandomIdGenerator = /** @class */function () {
      function RandomIdGenerator() {
        /**
         * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex
         * characters corresponding to 128 bits.
         */
        this.generateTraceId = getIdGenerator$1(TRACE_ID_BYTES);
        /**
         * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex
         * characters corresponding to 64 bits.
         */
        this.generateSpanId = getIdGenerator$1(SPAN_ID_BYTES);
      }
      return RandomIdGenerator;
    }();
    var SHARED_CHAR_CODES_ARRAY$1 = Array(32);
    function getIdGenerator$1(bytes) {
      return function generateId() {
        for (var i = 0; i < bytes * 2; i++) {
          SHARED_CHAR_CODES_ARRAY$1[i] = Math.floor(Math.random() * 16) + 48;
          // valid hex characters in the range 48-57 and 97-102
          if (SHARED_CHAR_CODES_ARRAY$1[i] >= 58) {
            SHARED_CHAR_CODES_ARRAY$1[i] += 39;
          }
        }
        return String.fromCharCode.apply(null, SHARED_CHAR_CODES_ARRAY$1.slice(0, bytes * 2));
      };
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * This class represents a basic tracer.
     */
    var Tracer = /** @class */function () {
      /**
       * Constructs a new Tracer instance.
       */
      function Tracer(instrumentationLibrary, config, _tracerProvider) {
        this._tracerProvider = _tracerProvider;
        var localConfig = mergeConfig(config);
        this._sampler = localConfig.sampler;
        this._generalLimits = localConfig.generalLimits;
        this._spanLimits = localConfig.spanLimits;
        this._idGenerator = config.idGenerator || new RandomIdGenerator();
        this.resource = _tracerProvider.resource;
        this.instrumentationLibrary = instrumentationLibrary;
      }
      /**
       * Starts a new Span or returns the default NoopSpan based on the sampling
       * decision.
       */
      Tracer.prototype.startSpan = function (name, options, context$1) {
        var _a, _b, _c;
        if (options === void 0) {
          options = {};
        }
        if (context$1 === void 0) {
          context$1 = context.active();
        }
        // remove span from context in case a root span is requested via options
        if (options.root) {
          context$1 = trace.deleteSpan(context$1);
        }
        var parentSpan = trace.getSpan(context$1);
        if (isTracingSuppressed(context$1)) {
          diag.debug('Instrumentation suppressed, returning Noop Span');
          var nonRecordingSpan = trace.wrapSpanContext(INVALID_SPAN_CONTEXT);
          return nonRecordingSpan;
        }
        var parentSpanContext = parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.spanContext();
        var spanId = this._idGenerator.generateSpanId();
        var traceId;
        var traceState;
        var parentSpanId;
        if (!parentSpanContext || !trace.isSpanContextValid(parentSpanContext)) {
          // New root span.
          traceId = this._idGenerator.generateTraceId();
        } else {
          // New child span.
          traceId = parentSpanContext.traceId;
          traceState = parentSpanContext.traceState;
          parentSpanId = parentSpanContext.spanId;
        }
        var spanKind = (_a = options.kind) !== null && _a !== void 0 ? _a : SpanKind.INTERNAL;
        var links = ((_b = options.links) !== null && _b !== void 0 ? _b : []).map(function (link) {
          return {
            context: link.context,
            attributes: sanitizeAttributes(link.attributes)
          };
        });
        var attributes = sanitizeAttributes(options.attributes);
        // make sampling decision
        var samplingResult = this._sampler.shouldSample(context$1, traceId, name, spanKind, attributes, links);
        traceState = (_c = samplingResult.traceState) !== null && _c !== void 0 ? _c : traceState;
        var traceFlags = samplingResult.decision === SamplingDecision$1.RECORD_AND_SAMPLED ? TraceFlags.SAMPLED : TraceFlags.NONE;
        var spanContext = {
          traceId: traceId,
          spanId: spanId,
          traceFlags: traceFlags,
          traceState: traceState
        };
        if (samplingResult.decision === SamplingDecision$1.NOT_RECORD) {
          diag.debug('Recording is off, propagating context in a non-recording span');
          var nonRecordingSpan = trace.wrapSpanContext(spanContext);
          return nonRecordingSpan;
        }
        // Set initial span attributes. The attributes object may have been mutated
        // by the sampler, so we sanitize the merged attributes before setting them.
        var initAttributes = sanitizeAttributes(Object.assign(attributes, samplingResult.attributes));
        var span = new Span(this, context$1, name, spanContext, spanKind, parentSpanId, links, options.startTime, undefined, initAttributes);
        return span;
      };
      Tracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : context.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = trace.setSpan(parentContext, span);
        return context.with(contextWithSpanSet, fn, undefined, span);
      };
      /** Returns the active {@link GeneralLimits}. */
      Tracer.prototype.getGeneralLimits = function () {
        return this._generalLimits;
      };
      /** Returns the active {@link SpanLimits}. */
      Tracer.prototype.getSpanLimits = function () {
        return this._spanLimits;
      };
      Tracer.prototype.getActiveSpanProcessor = function () {
        return this._tracerProvider.getActiveSpanProcessor();
      };
      return Tracer;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __values$1 = undefined && undefined.__values || function (o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function () {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    /**
     * Implementation of the {@link SpanProcessor} that simply forwards all
     * received events to a list of {@link SpanProcessor}s.
     */
    var MultiSpanProcessor = /** @class */function () {
      function MultiSpanProcessor(_spanProcessors) {
        this._spanProcessors = _spanProcessors;
      }
      MultiSpanProcessor.prototype.forceFlush = function () {
        var e_1, _a;
        var promises = [];
        try {
          for (var _b = __values$1(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
            var spanProcessor = _c.value;
            promises.push(spanProcessor.forceFlush());
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return new Promise(function (resolve) {
          Promise.all(promises).then(function () {
            resolve();
          }).catch(function (error) {
            globalErrorHandler(error || new Error('MultiSpanProcessor: forceFlush failed'));
            resolve();
          });
        });
      };
      MultiSpanProcessor.prototype.onStart = function (span, context) {
        var e_2, _a;
        try {
          for (var _b = __values$1(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
            var spanProcessor = _c.value;
            spanProcessor.onStart(span, context);
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      };
      MultiSpanProcessor.prototype.onEnd = function (span) {
        var e_3, _a;
        try {
          for (var _b = __values$1(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
            var spanProcessor = _c.value;
            spanProcessor.onEnd(span);
          }
        } catch (e_3_1) {
          e_3 = {
            error: e_3_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
      };
      MultiSpanProcessor.prototype.shutdown = function () {
        var e_4, _a;
        var promises = [];
        try {
          for (var _b = __values$1(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
            var spanProcessor = _c.value;
            promises.push(spanProcessor.shutdown());
          }
        } catch (e_4_1) {
          e_4 = {
            error: e_4_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_4) throw e_4.error;
          }
        }
        return new Promise(function (resolve, reject) {
          Promise.all(promises).then(function () {
            resolve();
          }, reject);
        });
      };
      return MultiSpanProcessor;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /** No-op implementation of SpanProcessor */
    var NoopSpanProcessor = /** @class */function () {
      function NoopSpanProcessor() {}
      NoopSpanProcessor.prototype.onStart = function (_span, _context) {};
      NoopSpanProcessor.prototype.onEnd = function (_span) {};
      NoopSpanProcessor.prototype.shutdown = function () {
        return Promise.resolve();
      };
      NoopSpanProcessor.prototype.forceFlush = function () {
        return Promise.resolve();
      };
      return NoopSpanProcessor;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var ForceFlushState;
    (function (ForceFlushState) {
      ForceFlushState[ForceFlushState["resolved"] = 0] = "resolved";
      ForceFlushState[ForceFlushState["timeout"] = 1] = "timeout";
      ForceFlushState[ForceFlushState["error"] = 2] = "error";
      ForceFlushState[ForceFlushState["unresolved"] = 3] = "unresolved";
    })(ForceFlushState || (ForceFlushState = {}));
    /**
     * This class represents a basic tracer provider which platform libraries can extend
     */
    var BasicTracerProvider = /** @class */function () {
      function BasicTracerProvider(config) {
        if (config === void 0) {
          config = {};
        }
        var _a;
        this._registeredSpanProcessors = [];
        this._tracers = new Map();
        var mergedConfig = merge({}, loadDefaultConfig(), reconfigureLimits(config));
        this.resource = (_a = mergedConfig.resource) !== null && _a !== void 0 ? _a : Resource.empty();
        this.resource = Resource.default().merge(this.resource);
        this._config = Object.assign({}, mergedConfig, {
          resource: this.resource
        });
        var defaultExporter = this._buildExporterFromEnv();
        if (defaultExporter !== undefined) {
          var batchProcessor = new BatchSpanProcessor(defaultExporter);
          this.activeSpanProcessor = batchProcessor;
        } else {
          this.activeSpanProcessor = new NoopSpanProcessor();
        }
      }
      BasicTracerProvider.prototype.getTracer = function (name, version, options) {
        var key = name + "@" + (version || '') + ":" + ((options === null || options === void 0 ? void 0 : options.schemaUrl) || '');
        if (!this._tracers.has(key)) {
          this._tracers.set(key, new Tracer({
            name: name,
            version: version,
            schemaUrl: options === null || options === void 0 ? void 0 : options.schemaUrl
          }, this._config, this));
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this._tracers.get(key);
      };
      /**
       * Adds a new {@link SpanProcessor} to this tracer.
       * @param spanProcessor the new SpanProcessor to be added.
       */
      BasicTracerProvider.prototype.addSpanProcessor = function (spanProcessor) {
        if (this._registeredSpanProcessors.length === 0) {
          // since we might have enabled by default a batchProcessor, we disable it
          // before adding the new one
          this.activeSpanProcessor.shutdown().catch(function (err) {
            return diag.error('Error while trying to shutdown current span processor', err);
          });
        }
        this._registeredSpanProcessors.push(spanProcessor);
        this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);
      };
      BasicTracerProvider.prototype.getActiveSpanProcessor = function () {
        return this.activeSpanProcessor;
      };
      /**
       * Register this TracerProvider for use with the OpenTelemetry API.
       * Undefined values may be replaced with defaults, and
       * null values will be skipped.
       *
       * @param config Configuration object for SDK registration
       */
      BasicTracerProvider.prototype.register = function (config) {
        if (config === void 0) {
          config = {};
        }
        trace.setGlobalTracerProvider(this);
        if (config.propagator === undefined) {
          config.propagator = this._buildPropagatorFromEnv();
        }
        if (config.contextManager) {
          context.setGlobalContextManager(config.contextManager);
        }
        if (config.propagator) {
          propagation.setGlobalPropagator(config.propagator);
        }
      };
      BasicTracerProvider.prototype.forceFlush = function () {
        var timeout = this._config.forceFlushTimeoutMillis;
        var promises = this._registeredSpanProcessors.map(function (spanProcessor) {
          return new Promise(function (resolve) {
            var state;
            var timeoutInterval = setTimeout(function () {
              resolve(new Error("Span processor did not completed within timeout period of " + timeout + " ms"));
              state = ForceFlushState.timeout;
            }, timeout);
            spanProcessor.forceFlush().then(function () {
              clearTimeout(timeoutInterval);
              if (state !== ForceFlushState.timeout) {
                state = ForceFlushState.resolved;
                resolve(state);
              }
            }).catch(function (error) {
              clearTimeout(timeoutInterval);
              state = ForceFlushState.error;
              resolve(error);
            });
          });
        });
        return new Promise(function (resolve, reject) {
          Promise.all(promises).then(function (results) {
            var errors = results.filter(function (result) {
              return result !== ForceFlushState.resolved;
            });
            if (errors.length > 0) {
              reject(errors);
            } else {
              resolve();
            }
          }).catch(function (error) {
            return reject([error]);
          });
        });
      };
      BasicTracerProvider.prototype.shutdown = function () {
        return this.activeSpanProcessor.shutdown();
      };
      /**
       * TS cannot yet infer the type of this.constructor:
       * https://github.com/Microsoft/TypeScript/issues/3841#issuecomment-337560146
       * There is no need to override either of the getters in your child class.
       * The type of the registered component maps should be the same across all
       * classes in the inheritance tree.
       */
      BasicTracerProvider.prototype._getPropagator = function (name) {
        var _a;
        return (_a = this.constructor._registeredPropagators.get(name)) === null || _a === void 0 ? void 0 : _a();
      };
      BasicTracerProvider.prototype._getSpanExporter = function (name) {
        var _a;
        return (_a = this.constructor._registeredExporters.get(name)) === null || _a === void 0 ? void 0 : _a();
      };
      BasicTracerProvider.prototype._buildPropagatorFromEnv = function () {
        var _this = this;
        // per spec, propagators from env must be deduplicated
        var uniquePropagatorNames = Array.from(new Set(getEnv().OTEL_PROPAGATORS));
        var propagators = uniquePropagatorNames.map(function (name) {
          var propagator = _this._getPropagator(name);
          if (!propagator) {
            diag.warn("Propagator \"" + name + "\" requested through environment variable is unavailable.");
          }
          return propagator;
        });
        var validPropagators = propagators.reduce(function (list, item) {
          if (item) {
            list.push(item);
          }
          return list;
        }, []);
        if (validPropagators.length === 0) {
          return;
        } else if (uniquePropagatorNames.length === 1) {
          return validPropagators[0];
        } else {
          return new CompositePropagator({
            propagators: validPropagators
          });
        }
      };
      BasicTracerProvider.prototype._buildExporterFromEnv = function () {
        var exporterName = getEnv().OTEL_TRACES_EXPORTER;
        if (exporterName === 'none' || exporterName === '') return;
        var exporter = this._getSpanExporter(exporterName);
        if (!exporter) {
          diag.error("Exporter \"" + exporterName + "\" requested through environment variable is unavailable.");
        }
        return exporter;
      };
      BasicTracerProvider._registeredPropagators = new Map([['tracecontext', function () {
        return new W3CTraceContextPropagator();
      }], ['baggage', function () {
        return new W3CBaggagePropagator();
      }]]);
      BasicTracerProvider._registeredExporters = new Map();
      return BasicTracerProvider;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __read$4 = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = undefined && undefined.__spreadArray || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    /**
     * Stack Context Manager for managing the state in web
     * it doesn't fully support the async calls though
     */
    var StackContextManager = /** @class */function () {
      function StackContextManager() {
        /**
         * whether the context manager is enabled or not
         */
        this._enabled = false;
        /**
         * Keeps the reference to current context
         */
        this._currentContext = ROOT_CONTEXT;
      }
      /**
       *
       * @param context
       * @param target Function to be executed within the context
       */
      // eslint-disable-next-line @typescript-eslint/ban-types
      StackContextManager.prototype._bindFunction = function (context, target) {
        if (context === void 0) {
          context = ROOT_CONTEXT;
        }
        var manager = this;
        var contextWrapper = function () {
          var _this = this;
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return manager.with(context, function () {
            return target.apply(_this, args);
          });
        };
        Object.defineProperty(contextWrapper, 'length', {
          enumerable: false,
          configurable: true,
          writable: false,
          value: target.length
        });
        return contextWrapper;
      };
      /**
       * Returns the active context
       */
      StackContextManager.prototype.active = function () {
        return this._currentContext;
      };
      /**
       * Binds a the certain context or the active one to the target function and then returns the target
       * @param context A context (span) to be bind to target
       * @param target a function or event emitter. When target or one of its callbacks is called,
       *  the provided context will be used as the active context for the duration of the call.
       */
      StackContextManager.prototype.bind = function (context, target) {
        // if no specific context to propagate is given, we use the current one
        if (context === undefined) {
          context = this.active();
        }
        if (typeof target === 'function') {
          return this._bindFunction(context, target);
        }
        return target;
      };
      /**
       * Disable the context manager (clears the current context)
       */
      StackContextManager.prototype.disable = function () {
        this._currentContext = ROOT_CONTEXT;
        this._enabled = false;
        return this;
      };
      /**
       * Enables the context manager and creates a default(root) context
       */
      StackContextManager.prototype.enable = function () {
        if (this._enabled) {
          return this;
        }
        this._enabled = true;
        this._currentContext = ROOT_CONTEXT;
        return this;
      };
      /**
       * Calls the callback function [fn] with the provided [context]. If [context] is undefined then it will use the window.
       * The context will be set as active
       * @param context
       * @param fn Callback function
       * @param thisArg optional receiver to be used for calling fn
       * @param args optional arguments forwarded to fn
       */
      StackContextManager.prototype.with = function (context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        var previousContext = this._currentContext;
        this._currentContext = context || ROOT_CONTEXT;
        try {
          return fn.call.apply(fn, __spreadArray([thisArg], __read$4(args), false));
        } finally {
          this._currentContext = previousContext;
        }
      };
      return StackContextManager;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __extends$3 = undefined && undefined.__extends || function () {
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    /**
     * This class represents a web tracer with {@link StackContextManager}
     */
    var WebTracerProvider = /** @class */function (_super) {
      __extends$3(WebTracerProvider, _super);
      /**
       * Constructs a new Tracer instance.
       * @param config Web Tracer config
       */
      function WebTracerProvider(config) {
        if (config === void 0) {
          config = {};
        }
        var _this = _super.call(this, config) || this;
        if (config.contextManager) {
          throw 'contextManager should be defined in register method not in' + ' constructor';
        }
        if (config.propagator) {
          throw 'propagator should be defined in register method not in constructor';
        }
        return _this;
      }
      /**
       * Register this TracerProvider for use with the OpenTelemetry API.
       * Undefined values may be replaced with defaults, and
       * null values will be skipped.
       *
       * @param config Configuration object for SDK registration
       */
      WebTracerProvider.prototype.register = function (config) {
        if (config === void 0) {
          config = {};
        }
        if (config.contextManager === undefined) {
          config.contextManager = new StackContextManager();
        }
        if (config.contextManager) {
          config.contextManager.enable();
        }
        _super.prototype.register.call(this, config);
      };
      return WebTracerProvider;
    }(BasicTracerProvider);

    // This code will eventually be packaged upstream into a WebSDK package.
    // Once it is released as a package, this distro will depend directly on the upstream package.
    // https://github.com/open-telemetry/opentelemetry-js/pull/4325
    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    const SESSION_ID_BYTES = 16;
    const SHARED_CHAR_CODES_ARRAY = Array(32);
    class SessionIdSpanProcessor {
      constructor() {
        this._idGenerator = getIdGenerator(SESSION_ID_BYTES);
        this._sessionId = this._idGenerator();
      }
      onStart(span) {
        span.setAttribute('session.id', this._sessionId);
      }
      onEnd() {}
      forceFlush() {
        return Promise.resolve();
      }
      shutdown() {
        return Promise.resolve();
      }
    }
    function getIdGenerator(bytes) {
      return function generateId() {
        for (let i = 0; i < bytes * 2; i++) {
          SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;
          // valid hex characters in the range 48-57 and 97-102
          if (SHARED_CHAR_CODES_ARRAY[i] >= 58) {
            SHARED_CHAR_CODES_ARRAY[i] += 39;
          }
        }
        return String.fromCharCode.apply(null, SHARED_CHAR_CODES_ARRAY.slice(0, bytes * 2));
      };
    }

    var BROWSER_ATTRIBUTES = {
      PLATFORM: 'browser.platform',
      BRANDS: 'browser.brands',
      MOBILE: 'browser.mobile',
      LANGUAGE: 'browser.language',
      USER_AGENT: 'browser.user_agent'
    };

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = undefined && undefined.__generator || function (thisArg, body) {
      var _ = {
          label: 0,
          sent: function () {
            if (t[0] & 1) throw t[1];
            return t[1];
          },
          trys: [],
          ops: []
        },
        f,
        y,
        t,
        g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;
      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    /**
     * BrowserDetector will be used to detect the resources related to browser.
     */
    var BrowserDetector = /** @class */function () {
      function BrowserDetector() {}
      BrowserDetector.prototype.detect = function (config) {
        return __awaiter(this, void 0, void 0, function () {
          var isBrowser, browserResource;
          return __generator(this, function (_a) {
            isBrowser = typeof navigator !== 'undefined';
            if (!isBrowser) {
              return [2 /*return*/, Resource.empty()];
            }
            browserResource = getBrowserAttributes();
            return [2 /*return*/, this._getResourceAttributes(browserResource, config)];
          });
        });
      };
      /**
       * Validates browser resource attribute map from browser variables
       *
       * @param browserResource The un-sanitized resource attributes from browser as key/value pairs.
       * @param config: Config
       * @returns The sanitized resource attributes.
       */
      BrowserDetector.prototype._getResourceAttributes = function (browserResource, _config) {
        if (!browserResource[BROWSER_ATTRIBUTES.USER_AGENT] && !browserResource[BROWSER_ATTRIBUTES.PLATFORM]) {
          diag.debug('BrowserDetector failed: Unable to find required browser resources. ');
          return Resource.empty();
        } else {
          return new Resource(browserResource);
        }
      };
      return BrowserDetector;
    }();
    // Add Browser related attributes to resources
    function getBrowserAttributes() {
      var browserAttribs = {};
      var userAgentData = navigator.userAgentData;
      if (userAgentData) {
        browserAttribs[BROWSER_ATTRIBUTES.PLATFORM] = userAgentData.platform;
        browserAttribs[BROWSER_ATTRIBUTES.BRANDS] = userAgentData.brands.map(function (b) {
          return b.brand + " " + b.version;
        });
        browserAttribs[BROWSER_ATTRIBUTES.MOBILE] = userAgentData.mobile;
      } else {
        browserAttribs[BROWSER_ATTRIBUTES.USER_AGENT] = navigator.userAgent;
      }
      browserAttribs[BROWSER_ATTRIBUTES.LANGUAGE] = navigator.language;
      return browserAttribs;
    }
    var browserDetector = new BrowserDetector();

    // This code will eventually be packaged upstream into a WebSDK package.
    // Once it is released as a package, this distro will depend directly on the upstream package.
    // https://github.com/open-telemetry/opentelemetry-js/pull/4325
    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /** This class represents everything needed to register a fully configured OpenTelemetry Web SDK */
    class WebSDK {
      /**
       * Create a new Web SDK instance
       */
      constructor(configuration = {}) {
        var _a, _b, _c, _d;
        this._resource = (_a = configuration.resource) !== null && _a !== void 0 ? _a : new Resource({});
        this._resourceDetectors = (_b = configuration.resourceDetectors) !== null && _b !== void 0 ? _b : [browserDetector];
        this._serviceName = configuration.serviceName;
        this._autoDetectResources = (_c = configuration.autoDetectResources) !== null && _c !== void 0 ? _c : true;
        if (configuration.spanProcessor || configuration.traceExporter) {
          const tracerProviderConfig = {};
          if (configuration.sampler) {
            tracerProviderConfig.sampler = configuration.sampler;
          }
          if (configuration.spanLimits) {
            tracerProviderConfig.spanLimits = configuration.spanLimits;
          }
          if (configuration.idGenerator) {
            tracerProviderConfig.idGenerator = configuration.idGenerator;
          }
          const spanProcessor = (_d = configuration.spanProcessor) !== null && _d !== void 0 ? _d : new BatchSpanProcessor(configuration.traceExporter);
          this._tracerProviderConfig = {
            tracerConfig: tracerProviderConfig,
            spanProcessor,
            contextManager: configuration.contextManager,
            textMapPropagator: configuration.textMapPropagator
          };
        }
        let instrumentations = [];
        if (configuration.instrumentations) {
          instrumentations = configuration.instrumentations;
        }
        this._instrumentations = instrumentations;
      }
      /**
       * Call this method to construct SDK components and register them with the OpenTelemetry API.
       */
      start() {
        var _a, _b, _c;
        if (this._disabled) {
          return;
        }
        registerInstrumentations({
          instrumentations: this._instrumentations
        });
        if (this._autoDetectResources) {
          const internalConfig = {
            detectors: this._resourceDetectors
          };
          this._resource = this._resource.merge(detectResourcesSync(internalConfig));
        }
        this._resource = this._serviceName === undefined ? this._resource : this._resource.merge(new Resource({
          [SEMRESATTRS_SERVICE_NAME]: this._serviceName
        }));
        const tracerProvider = new WebTracerProvider(Object.assign(Object.assign({}, (_a = this._tracerProviderConfig) === null || _a === void 0 ? void 0 : _a.tracerConfig), {
          resource: this._resource
        }));
        this._tracerProvider = tracerProvider;
        if (this._tracerProviderConfig) {
          tracerProvider.addSpanProcessor(this._tracerProviderConfig.spanProcessor);
        }
        tracerProvider.register({
          contextManager: (_b = this._tracerProviderConfig) === null || _b === void 0 ? void 0 : _b.contextManager,
          propagator: (_c = this._tracerProviderConfig) === null || _c === void 0 ? void 0 : _c.textMapPropagator
        });
        // add processor for adding the sessionId attribute
        tracerProvider.addSpanProcessor(new SessionIdSpanProcessor());
      }
      /* Experimental getter method: not currently part of the upstream
       * sdk's API */
      getResourceAttributes() {
        return this._resource.attributes;
      }
      shutdown() {
        const promises = [];
        if (this._tracerProvider) {
          promises.push(this._tracerProvider.shutdown());
        }
        return Promise.all(promises)
        // return void instead of the array from Promise.all
        .then(() => {});
      }
    }

    const VERSION = '0.6.0';

    function configureHoneycombResource() {
      return new Resource({
        'honeycomb.distro.version': VERSION,
        'honeycomb.distro.runtime_version': 'browser'
      });
    }

    const defaultConfig = {
      path: true,
      hash: true,
      hostname: true,
      referrer: true,
      url: false,
      search: false
    };
    function configureEntryPageResource(config) {
      if (config === false || !(window === null || window === void 0 ? void 0 : window.location)) {
        return new Resource({});
      }
      const options = getOptions(config);
      const {
        href,
        pathname,
        search,
        hash,
        hostname
      } = window.location;
      const attributes = {
        'entry_page.url': optionalAttribute(options.url, href),
        'entry_page.path': optionalAttribute(options.path, pathname),
        'entry_page.search': optionalAttribute(options.search, search),
        'entry_page.hash': optionalAttribute(options.hash, hash),
        'entry_page.hostname': optionalAttribute(options.hostname, hostname),
        'entry_page.referrer': optionalAttribute(options.referrer, document.referrer)
      };
      return new Resource(attributes);
    }
    function getOptions(config) {
      if (!config) {
        return defaultConfig;
      }
      return Object.assign(Object.assign({}, defaultConfig), config);
    }
    function optionalAttribute(shouldInclude, attribute) {
      if (!shouldInclude) {
        return undefined;
      }
      return attribute;
    }

    var uaParser = {exports: {}};

    (function (module, exports) {
      /////////////////////////////////////////////////////////////////////////////////
      /* UAParser.js v1.0.38
         Copyright © 2012-2021 Faisal Salman <f@faisalman.com>
         MIT License */ /*
                        Detect Browser, Engine, OS, CPU, and Device type/model from User-Agent data.
                        Supports browser & node.js environment. 
                        Demo   : https://faisalman.github.io/ua-parser-js
                        Source : https://github.com/faisalman/ua-parser-js */
      /////////////////////////////////////////////////////////////////////////////////

      (function (window, undefined$1) {

        //////////////
        // Constants
        /////////////
        var LIBVERSION = '1.0.38',
          EMPTY = '',
          UNKNOWN = '?',
          FUNC_TYPE = 'function',
          UNDEF_TYPE = 'undefined',
          OBJ_TYPE = 'object',
          STR_TYPE = 'string',
          MAJOR = 'major',
          MODEL = 'model',
          NAME = 'name',
          TYPE = 'type',
          VENDOR = 'vendor',
          VERSION = 'version',
          ARCHITECTURE = 'architecture',
          CONSOLE = 'console',
          MOBILE = 'mobile',
          TABLET = 'tablet',
          SMARTTV = 'smarttv',
          WEARABLE = 'wearable',
          EMBEDDED = 'embedded',
          UA_MAX_LENGTH = 500;
        var AMAZON = 'Amazon',
          APPLE = 'Apple',
          ASUS = 'ASUS',
          BLACKBERRY = 'BlackBerry',
          BROWSER = 'Browser',
          CHROME = 'Chrome',
          EDGE = 'Edge',
          FIREFOX = 'Firefox',
          GOOGLE = 'Google',
          HUAWEI = 'Huawei',
          LG = 'LG',
          MICROSOFT = 'Microsoft',
          MOTOROLA = 'Motorola',
          OPERA = 'Opera',
          SAMSUNG = 'Samsung',
          SHARP = 'Sharp',
          SONY = 'Sony',
          XIAOMI = 'Xiaomi',
          ZEBRA = 'Zebra',
          FACEBOOK = 'Facebook',
          CHROMIUM_OS = 'Chromium OS',
          MAC_OS = 'Mac OS';

        ///////////
        // Helper
        //////////

        var extend = function (regexes, extensions) {
            var mergedRegexes = {};
            for (var i in regexes) {
              if (extensions[i] && extensions[i].length % 2 === 0) {
                mergedRegexes[i] = extensions[i].concat(regexes[i]);
              } else {
                mergedRegexes[i] = regexes[i];
              }
            }
            return mergedRegexes;
          },
          enumerize = function (arr) {
            var enums = {};
            for (var i = 0; i < arr.length; i++) {
              enums[arr[i].toUpperCase()] = arr[i];
            }
            return enums;
          },
          has = function (str1, str2) {
            return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
          },
          lowerize = function (str) {
            return str.toLowerCase();
          },
          majorize = function (version) {
            return typeof version === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split('.')[0] : undefined$1;
          },
          trim = function (str, len) {
            if (typeof str === STR_TYPE) {
              str = str.replace(/^\s\s*/, EMPTY);
              return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
            }
          };

        ///////////////
        // Map helper
        //////////////

        var rgxMapper = function (ua, arrays) {
            var i = 0,
              j,
              k,
              p,
              q,
              matches,
              match;

            // loop through all regexes maps
            while (i < arrays.length && !matches) {
              var regex = arrays[i],
                // even sequence (0,2,4,..)
                props = arrays[i + 1]; // odd sequence (1,3,5,..)
              j = k = 0;

              // try matching uastring with regexes
              while (j < regex.length && !matches) {
                if (!regex[j]) {
                  break;
                }
                matches = regex[j++].exec(ua);
                if (!!matches) {
                  for (p = 0; p < props.length; p++) {
                    match = matches[++k];
                    q = props[p];
                    // check if given property is actually array
                    if (typeof q === OBJ_TYPE && q.length > 0) {
                      if (q.length === 2) {
                        if (typeof q[1] == FUNC_TYPE) {
                          // assign modified match
                          this[q[0]] = q[1].call(this, match);
                        } else {
                          // assign given value, ignore regex match
                          this[q[0]] = q[1];
                        }
                      } else if (q.length === 3) {
                        // check whether function or regex
                        if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                          // call function (usually string mapper)
                          this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined$1;
                        } else {
                          // sanitize match using given regex
                          this[q[0]] = match ? match.replace(q[1], q[2]) : undefined$1;
                        }
                      } else if (q.length === 4) {
                        this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined$1;
                      }
                    } else {
                      this[q] = match ? match : undefined$1;
                    }
                  }
                }
              }
              i += 2;
            }
          },
          strMapper = function (str, map) {
            for (var i in map) {
              // check if current value is array
              if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                for (var j = 0; j < map[i].length; j++) {
                  if (has(map[i][j], str)) {
                    return i === UNKNOWN ? undefined$1 : i;
                  }
                }
              } else if (has(map[i], str)) {
                return i === UNKNOWN ? undefined$1 : i;
              }
            }
            return str;
          };

        ///////////////
        // String map
        //////////////

        // Safari < 3.0
        var oldSafariMap = {
            '1.0': '/8',
            '1.2': '/1',
            '1.3': '/3',
            '2.0': '/412',
            '2.0.2': '/416',
            '2.0.3': '/417',
            '2.0.4': '/419',
            '?': '/'
          },
          windowsVersionMap = {
            'ME': '4.90',
            'NT 3.11': 'NT3.51',
            'NT 4.0': 'NT4.0',
            '2000': 'NT 5.0',
            'XP': ['NT 5.1', 'NT 5.2'],
            'Vista': 'NT 6.0',
            '7': 'NT 6.1',
            '8': 'NT 6.2',
            '8.1': 'NT 6.3',
            '10': ['NT 6.4', 'NT 10.0'],
            'RT': 'ARM'
          };

        //////////////
        // Regex map
        /////////////

        var regexes = {
          browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i // Chrome for Android/iOS
          ], [VERSION, [NAME, 'Chrome']], [/edg(?:e|ios|a)?\/([\w\.]+)/i // Microsoft Edge
          ], [VERSION, [NAME, 'Edge']], [
          // Presto based
          /(opera mini)\/([-\w\.]+)/i,
          // Opera Mini
          /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
          // Opera Mobi/Tablet
          /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i // Opera
          ], [NAME, VERSION], [/opios[\/ ]+([\w\.]+)/i // Opera mini on iphone >= 8.0
          ], [VERSION, [NAME, OPERA + ' Mini']], [/\bop(?:rg)?x\/([\w\.]+)/i // Opera GX
          ], [VERSION, [NAME, OPERA + ' GX']], [/\bopr\/([\w\.]+)/i // Opera Webkit
          ], [VERSION, [NAME, OPERA]], [
          // Mixed
          /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i // Baidu
          ], [VERSION, [NAME, 'Baidu']], [/(kindle)\/([\w\.]+)/i,
          // Kindle
          /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
          // Lunascape/Maxthon/Netfront/Jasmine/Blazer
          // Trident based
          /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i,
          // Avant/IEMobile/SlimBrowser
          /(?:ms|\()(ie) ([\w\.]+)/i,
          // Internet Explorer

          // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
          /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
          // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ
          /(heytap|ovi)browser\/([\d\.]+)/i,
          // Heytap/Ovi
          /(weibo)__([\d\.]+)/i // Weibo
          ], [NAME, VERSION], [/\bddg\/([\w\.]+)/i // DuckDuckGo
          ], [VERSION, [NAME, 'DuckDuckGo']], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i // UCBrowser
          ], [VERSION, [NAME, 'UC' + BROWSER]], [/microm.+\bqbcore\/([\w\.]+)/i,
          // WeChat Desktop for Windows Built-in Browser
          /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i // WeChat
          ], [VERSION, [NAME, 'WeChat']], [/konqueror\/([\w\.]+)/i // Konqueror
          ], [VERSION, [NAME, 'Konqueror']], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i // IE11
          ], [VERSION, [NAME, 'IE']], [/ya(?:search)?browser\/([\w\.]+)/i // Yandex
          ], [VERSION, [NAME, 'Yandex']], [/slbrowser\/([\w\.]+)/i // Smart Lenovo Browser
          ], [VERSION, [NAME, 'Smart Lenovo ' + BROWSER]], [/(avast|avg)\/([\w\.]+)/i // Avast/AVG Secure Browser
          ], [[NAME, /(.+)/, '$1 Secure ' + BROWSER], VERSION], [/\bfocus\/([\w\.]+)/i // Firefox Focus
          ], [VERSION, [NAME, FIREFOX + ' Focus']], [/\bopt\/([\w\.]+)/i // Opera Touch
          ], [VERSION, [NAME, OPERA + ' Touch']], [/coc_coc\w+\/([\w\.]+)/i // Coc Coc Browser
          ], [VERSION, [NAME, 'Coc Coc']], [/dolfin\/([\w\.]+)/i // Dolphin
          ], [VERSION, [NAME, 'Dolphin']], [/coast\/([\w\.]+)/i // Opera Coast
          ], [VERSION, [NAME, OPERA + ' Coast']], [/miuibrowser\/([\w\.]+)/i // MIUI Browser
          ], [VERSION, [NAME, 'MIUI ' + BROWSER]], [/fxios\/([-\w\.]+)/i // Firefox for iOS
          ], [VERSION, [NAME, FIREFOX]], [/\bqihu|(qi?ho?o?|360)browser/i // 360
          ], [[NAME, '360 ' + BROWSER]], [/(oculus|sailfish|huawei|vivo)browser\/([\w\.]+)/i], [[NAME, /(.+)/, '$1 ' + BROWSER], VERSION], [
          // Oculus/Sailfish/HuaweiBrowser/VivoBrowser
          /samsungbrowser\/([\w\.]+)/i // Samsung Internet
          ], [VERSION, [NAME, SAMSUNG + ' Internet']], [/(comodo_dragon)\/([\w\.]+)/i // Comodo Dragon
          ], [[NAME, /_/g, ' '], VERSION], [/metasr[\/ ]?([\d\.]+)/i // Sogou Explorer
          ], [VERSION, [NAME, 'Sogou Explorer']], [/(sogou)mo\w+\/([\d\.]+)/i // Sogou Mobile
          ], [[NAME, 'Sogou Mobile'], VERSION], [/(electron)\/([\w\.]+) safari/i,
          // Electron-based App
          /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
          // Tesla
          /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i // QQBrowser/2345 Browser
          ], [NAME, VERSION], [/(lbbrowser)/i,
          // LieBao Browser
          /\[(linkedin)app\]/i // LinkedIn App for iOS & Android
          ], [NAME], [
          // WebView
          /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i // Facebook App for iOS & Android
          ], [[NAME, FACEBOOK], VERSION], [/(Klarna)\/([\w\.]+)/i,
          // Klarna Shopping Browser for iOS & Android
          /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
          // Kakao App
          /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
          // Naver InApp
          /safari (line)\/([\w\.]+)/i,
          // Line App for iOS
          /\b(line)\/([\w\.]+)\/iab/i,
          // Line App for Android
          /(alipay)client\/([\w\.]+)/i,
          // Alipay
          /(twitter)(?:and| f.+e\/([\w\.]+))/i,
          // Twitter
          /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i // Chromium/Instagram/Snapchat
          ], [NAME, VERSION], [/\bgsa\/([\w\.]+) .*safari\//i // Google Search Appliance on iOS
          ], [VERSION, [NAME, 'GSA']], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i // TikTok
          ], [VERSION, [NAME, 'TikTok']], [/headlesschrome(?:\/([\w\.]+)| )/i // Chrome Headless
          ], [VERSION, [NAME, CHROME + ' Headless']], [/ wv\).+(chrome)\/([\w\.]+)/i // Chrome WebView
          ], [[NAME, CHROME + ' WebView'], VERSION], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i // Android Browser
          ], [VERSION, [NAME, 'Android ' + BROWSER]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i // Chrome/OmniWeb/Arora/Tizen/Nokia
          ], [NAME, VERSION], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i // Mobile Safari
          ], [VERSION, [NAME, 'Mobile Safari']], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i // Safari & Safari Mobile
          ], [VERSION, NAME], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i // Safari < 3.0
          ], [NAME, [VERSION, strMapper, oldSafariMap]], [/(webkit|khtml)\/([\w\.]+)/i], [NAME, VERSION], [
          // Gecko based
          /(navigator|netscape\d?)\/([-\w\.]+)/i // Netscape
          ], [[NAME, 'Netscape'], VERSION], [/mobile vr; rv:([\w\.]+)\).+firefox/i // Firefox Reality
          ], [VERSION, [NAME, FIREFOX + ' Reality']], [/ekiohf.+(flow)\/([\w\.]+)/i,
          // Flow
          /(swiftfox)/i,
          // Swiftfox
          /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
          // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar
          /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
          // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
          /(firefox)\/([\w\.]+)/i,
          // Other Firefox-based
          /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
          // Mozilla

          // Other
          /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
          // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser
          /(links) \(([\w\.]+)/i,
          // Links
          /panasonic;(viera)/i // Panasonic Viera
          ], [NAME, VERSION], [/(cobalt)\/([\w\.]+)/i // Cobalt
          ], [NAME, [VERSION, /master.|lts./, ""]]],
          cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i // AMD64 (x64)
          ], [[ARCHITECTURE, 'amd64']], [/(ia32(?=;))/i // IA32 (quicktime)
          ], [[ARCHITECTURE, lowerize]], [/((?:i[346]|x)86)[;\)]/i // IA32 (x86)
          ], [[ARCHITECTURE, 'ia32']], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i // ARM64
          ], [[ARCHITECTURE, 'arm64']], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i // ARMHF
          ], [[ARCHITECTURE, 'armhf']], [
          // PocketPC mistakenly identified as PowerPC
          /windows (ce|mobile); ppc;/i], [[ARCHITECTURE, 'arm']], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i // PowerPC
          ], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [/(sun4\w)[;\)]/i // SPARC
          ], [[ARCHITECTURE, 'sparc']], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
          // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
          ], [[ARCHITECTURE, lowerize]]],
          device: [[
          //////////////////////////
          // MOBILES & TABLETS
          /////////////////////////

          // Samsung
          /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [
          // Apple
          /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i // iPod/iPhone
          ], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [/\((ipad);[-\w\),; ]+apple/i,
          // iPad
          /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [/(macintosh);/i], [MODEL, [VENDOR, APPLE]], [
          // Sharp
          /\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [
          // Huawei
          /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [
          // Xiaomi
          /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,
          // Xiaomi POCO
          /\b; (\w+) build\/hm\1/i,
          // Xiaomi Hongmi 'numeric' models
          /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
          // Xiaomi Hongmi
          /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
          // Xiaomi Redmi
          /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,
          // Xiaomi Redmi 'numeric' models
          /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i // Xiaomi Mi
          ], [[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, MOBILE]], [/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i,
          // Redmi Pad
          /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i // Mi Pad tablets
          ], [[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, TABLET]], [
          // OPPO
          /; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [MODEL, [VENDOR, 'OPPO'], [TYPE, MOBILE]], [/\b(opd2\d{3}a?) bui/i], [MODEL, [VENDOR, 'OPPO'], [TYPE, TABLET]], [
          // Vivo
          /vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [MODEL, [VENDOR, 'Vivo'], [TYPE, MOBILE]], [
          // Realme
          /\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [MODEL, [VENDOR, 'Realme'], [TYPE, MOBILE]], [
          // Motorola
          /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [
          // LG
          /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [
          // Lenovo
          /(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [
          // Nokia
          /(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[MODEL, /_/g, ' '], [VENDOR, 'Nokia'], [TYPE, MOBILE]], [
          // Google
          /(pixel c)\b/i // Google Pixel C
          ], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i // Google Pixel
          ], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [
          // Sony
          /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[MODEL, 'Xperia Tablet'], [VENDOR, SONY], [TYPE, TABLET]], [
          // OnePlus
          / (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [
          // Amazon
          /(alexa)webm/i, /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i,
          // Kindle Fire without Silk / Echo Show
          /(kf[a-z]+)( bui|\)).+silk\//i // Kindle Fire HD
          ], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i // Fire Phone
          ], [[MODEL, /(.+)/g, 'Fire Phone $1'], [VENDOR, AMAZON], [TYPE, MOBILE]], [
          // BlackBerry
          /(playbook);[-\w\),; ]+(rim)/i // BlackBerry PlayBook
          ], [MODEL, VENDOR, [TYPE, TABLET]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i // BlackBerry 10
          ], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [
          // Asus
          /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [
          // HTC
          /(nexus 9)/i // HTC Nexus 9
          ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
          // HTC

          // ZTE
          /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
          ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [
          // Acer
          /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [
          // Meizu
          /droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [
          // Ulefone
          /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [MODEL, [VENDOR, 'Ulefone'], [TYPE, MOBILE]], [
          // MIXED
          /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i,
          // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
          /(hp) ([\w ]+\w)/i,
          // HP iPAQ
          /(asus)-?(\w+)/i,
          // Asus
          /(microsoft); (lumia[\w ]+)/i,
          // Microsoft Lumia
          /(lenovo)[-_ ]?([-\w]+)/i,
          // Lenovo
          /(jolla)/i,
          // Jolla
          /(oppo) ?([\w ]+) bui/i // OPPO
          ], [VENDOR, MODEL, [TYPE, MOBILE]], [/(kobo)\s(ereader|touch)/i,
          // Kobo
          /(archos) (gamepad2?)/i,
          // Archos
          /(hp).+(touchpad(?!.+tablet)|tablet)/i,
          // HP TouchPad
          /(kindle)\/([\w\.]+)/i,
          // Kindle
          /(nook)[\w ]+build\/(\w+)/i,
          // Nook
          /(dell) (strea[kpr\d ]*[\dko])/i,
          // Dell Streak
          /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
          // Le Pan Tablets
          /(trinity)[- ]*(t\d{3}) bui/i,
          // Trinity Tablets
          /(gigaset)[- ]+(q\w{1,9}) bui/i,
          // Gigaset Tablets
          /(vodafone) ([\w ]+)(?:\)| bui)/i // Vodafone
          ], [VENDOR, MODEL, [TYPE, TABLET]], [/(surface duo)/i // Surface Duo
          ], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i // Fairphone
          ], [MODEL, [VENDOR, 'Fairphone'], [TYPE, MOBILE]], [/(u304aa)/i // AT&T
          ], [MODEL, [VENDOR, 'AT&T'], [TYPE, MOBILE]], [/\bsie-(\w*)/i // Siemens
          ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [/\b(rct\w+) b/i // RCA Tablets
          ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [/\b(venue[\d ]{2,7}) b/i // Dell Venue Tablets
          ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [/\b(q(?:mv|ta)\w+) b/i // Verizon Tablet
          ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i // Barnes & Noble Tablet
          ], [MODEL, [VENDOR, 'Barnes & Noble'], [TYPE, TABLET]], [/\b(tm\d{3}\w+) b/i], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [/\b(k88) b/i // ZTE K Series Tablet
          ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [/\b(nx\d{3}j) b/i // ZTE Nubia
          ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [/\b(gen\d{3}) b.+49h/i // Swiss GEN Mobile
          ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [/\b(zur\d{3}) b/i // Swiss ZUR Tablet
          ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [/\b((zeki)?tb.*\b) b/i // Zeki Tablets
          ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i // Dragon Touch Tablet
          ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [/\b(ns-?\w{0,9}) b/i // Insignia Tablets
          ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [/\b((nxa|next)-?\w{0,9}) b/i // NextBook Tablets
          ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i // Voice Xtreme Phones
          ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [/\b(lvtel\-)?(v1[12]) b/i // LvTel Phones
          ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [/\b(ph-1) /i // Essential PH-1
          ], [MODEL, [VENDOR, 'Essential'], [TYPE, MOBILE]], [/\b(v(100md|700na|7011|917g).*\b) b/i // Envizen Tablets
          ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [/\b(trio[-\w\. ]+) b/i // MachSpeed Tablets
          ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [/\btu_(1491) b/i // Rotor Tablets
          ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [/(shield[\w ]+) b/i // Nvidia Shield Tablets
          ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, TABLET]], [/(sprint) (\w+)/i // Sprint Phones
          ], [VENDOR, MODEL, [TYPE, MOBILE]], [/(kin\.[onetw]{3})/i // Microsoft Kin
          ], [[MODEL, /\./g, ' '], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i // Zebra
          ], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [
          ///////////////////
          // SMARTTVS
          ///////////////////

          /smart-tv.+(samsung)/i // Samsung
          ], [VENDOR, [TYPE, SMARTTV]], [/hbbtv.+maple;(\d+)/i], [[MODEL, /^/, 'SmartTV'], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i // LG SmartTV
          ], [[VENDOR, LG], [TYPE, SMARTTV]], [/(apple) ?tv/i // Apple TV
          ], [VENDOR, [MODEL, APPLE + ' TV'], [TYPE, SMARTTV]], [/crkey/i // Google Chromecast
          ], [[MODEL, CHROME + 'cast'], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [/droid.+aft(\w+)( bui|\))/i // Fire TV
          ], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i // Sharp
          ], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]], [/(bravia[\w ]+)( bui|\))/i // Sony
          ], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [/(mitv-\w{5}) bui/i // Xiaomi
          ], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [/Hbbtv.*(technisat) (.*);/i // TechniSAT
          ], [VENDOR, MODEL, [TYPE, SMARTTV]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
          // Roku
          /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i // HbbTV devices
          ], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i // SmartTV from Unidentified Vendors
          ], [[TYPE, SMARTTV]], [
          ///////////////////
          // CONSOLES
          ///////////////////

          /(ouya)/i,
          // Ouya
          /(nintendo) ([wids3utch]+)/i // Nintendo
          ], [VENDOR, MODEL, [TYPE, CONSOLE]], [/droid.+; (shield) bui/i // Nvidia
          ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [/(playstation [345portablevi]+)/i // Playstation
          ], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i // Microsoft Xbox
          ], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [
          ///////////////////
          // WEARABLES
          ///////////////////

          /((pebble))app/i // Pebble
          ], [VENDOR, MODEL, [TYPE, WEARABLE]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i // Apple Watch
          ], [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]], [/droid.+; (glass) \d/i // Google Glass
          ], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [/droid.+; (wt63?0{2,3})\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [/(quest( \d| pro)?)/i // Oculus Quest
          ], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [
          ///////////////////
          // EMBEDDED
          ///////////////////

          /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i // Tesla
          ], [VENDOR, [TYPE, EMBEDDED]], [/(aeobc)\b/i // Echo Dot
          ], [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]], [
          ////////////////////
          // MIXED (GENERIC)
          ///////////////////

          /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i // Android Phones from Unidentified Vendors
          ], [MODEL, [TYPE, MOBILE]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i // Android Tablets from Unidentified Vendors
          ], [MODEL, [TYPE, TABLET]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i // Unidentifiable Tablet
          ], [[TYPE, TABLET]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i // Unidentifiable Mobile
          ], [[TYPE, MOBILE]], [/(android[-\w\. ]{0,9});.+buil/i // Generic Android Device
          ], [MODEL, [VENDOR, 'Generic']]],
          engine: [[/windows.+ edge\/([\w\.]+)/i // EdgeHTML
          ], [VERSION, [NAME, EDGE + 'HTML']], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i // Blink
          ], [VERSION, [NAME, 'Blink']], [/(presto)\/([\w\.]+)/i,
          // Presto
          /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
          // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
          /ekioh(flow)\/([\w\.]+)/i,
          // Flow
          /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
          // KHTML/Tasman/Links
          /(icab)[\/ ]([23]\.[\d\.]+)/i,
          // iCab
          /\b(libweb)/i], [NAME, VERSION], [/rv\:([\w\.]{1,9})\b.+(gecko)/i // Gecko
          ], [VERSION, NAME]],
          os: [[
          // Windows
          /microsoft (windows) (vista|xp)/i // Windows (iTunes)
          ], [NAME, VERSION], [/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i // Windows Phone
          ], [NAME, [VERSION, strMapper, windowsVersionMap]], [/windows nt 6\.2; (arm)/i,
          // Windows RT
          /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[VERSION, strMapper, windowsVersionMap], [NAME, 'Windows']], [
          // iOS/macOS
          /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
          // iOS
          /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i // Mac OS
          ], [[NAME, MAC_OS], [VERSION, /_/g, '.']], [
          // Mobile OSes
          /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i // Android-x86/HarmonyOS
          ], [VERSION, NAME], [
          // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS
          /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i,
          // Blackberry
          /(tizen|kaios)[\/ ]([\w\.]+)/i,
          // Tizen/KaiOS
          /\((series40);/i // Series 40
          ], [NAME, VERSION], [/\(bb(10);/i // BlackBerry 10
          ], [VERSION, [NAME, BLACKBERRY]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i // Symbian
          ], [VERSION, [NAME, 'Symbian']], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i // Firefox OS
          ], [VERSION, [NAME, FIREFOX + ' OS']], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i // WebOS
          ], [VERSION, [NAME, 'webOS']], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i // watchOS
          ], [VERSION, [NAME, 'watchOS']], [
          // Google Chromecast
          /crkey\/([\d\.]+)/i // Google Chromecast
          ], [VERSION, [NAME, CHROME + 'cast']], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i // Chromium OS
          ], [[NAME, CHROMIUM_OS], VERSION], [
          // Smart TVs
          /panasonic;(viera)/i,
          // Panasonic Viera
          /(netrange)mmh/i,
          // Netrange
          /(nettv)\/(\d+\.[\w\.]+)/i,
          // NetTV

          // Console
          /(nintendo|playstation) ([wids345portablevuch]+)/i,
          // Nintendo/Playstation
          /(xbox); +xbox ([^\);]+)/i,
          // Microsoft Xbox (360, One, X, S, Series X, Series S)

          // Other
          /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
          // Joli/Palm
          /(mint)[\/\(\) ]?(\w*)/i,
          // Mint
          /(mageia|vectorlinux)[; ]/i,
          // Mageia/VectorLinux
          /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
          // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
          /(hurd|linux) ?([\w\.]*)/i,
          // Hurd/Linux
          /(gnu) ?([\w\.]*)/i,
          // GNU
          /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
          // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
          /(haiku) (\w+)/i // Haiku
          ], [NAME, VERSION], [/(sunos) ?([\w\.\d]*)/i // Solaris
          ], [[NAME, 'Solaris'], VERSION], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
          // Solaris
          /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
          // AIX
          /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
          // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
          /(unix) ?([\w\.]*)/i // UNIX
          ], [NAME, VERSION]]
        };

        /////////////////
        // Constructor
        ////////////////

        var UAParser = function (ua, extensions) {
          if (typeof ua === OBJ_TYPE) {
            extensions = ua;
            ua = undefined$1;
          }
          if (!(this instanceof UAParser)) {
            return new UAParser(ua, extensions).getResult();
          }
          var _navigator = typeof window !== UNDEF_TYPE && window.navigator ? window.navigator : undefined$1;
          var _ua = ua || (_navigator && _navigator.userAgent ? _navigator.userAgent : EMPTY);
          var _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined$1;
          var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
          var _isSelfNav = _navigator && _navigator.userAgent == _ua;
          this.getBrowser = function () {
            var _browser = {};
            _browser[NAME] = undefined$1;
            _browser[VERSION] = undefined$1;
            rgxMapper.call(_browser, _ua, _rgxmap.browser);
            _browser[MAJOR] = majorize(_browser[VERSION]);
            // Brave-specific detection
            if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {
              _browser[NAME] = 'Brave';
            }
            return _browser;
          };
          this.getCPU = function () {
            var _cpu = {};
            _cpu[ARCHITECTURE] = undefined$1;
            rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
            return _cpu;
          };
          this.getDevice = function () {
            var _device = {};
            _device[VENDOR] = undefined$1;
            _device[MODEL] = undefined$1;
            _device[TYPE] = undefined$1;
            rgxMapper.call(_device, _ua, _rgxmap.device);
            if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
              _device[TYPE] = MOBILE;
            }
            // iPadOS-specific detection: identified as Mac, but has some iOS-only properties
            if (_isSelfNav && _device[MODEL] == 'Macintosh' && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {
              _device[MODEL] = 'iPad';
              _device[TYPE] = TABLET;
            }
            return _device;
          };
          this.getEngine = function () {
            var _engine = {};
            _engine[NAME] = undefined$1;
            _engine[VERSION] = undefined$1;
            rgxMapper.call(_engine, _ua, _rgxmap.engine);
            return _engine;
          };
          this.getOS = function () {
            var _os = {};
            _os[NAME] = undefined$1;
            _os[VERSION] = undefined$1;
            rgxMapper.call(_os, _ua, _rgxmap.os);
            if (_isSelfNav && !_os[NAME] && _uach && _uach.platform && _uach.platform != 'Unknown') {
              _os[NAME] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS); // backward compatibility
            }
            return _os;
          };
          this.getResult = function () {
            return {
              ua: this.getUA(),
              browser: this.getBrowser(),
              engine: this.getEngine(),
              os: this.getOS(),
              device: this.getDevice(),
              cpu: this.getCPU()
            };
          };
          this.getUA = function () {
            return _ua;
          };
          this.setUA = function (ua) {
            _ua = typeof ua === STR_TYPE && ua.length > UA_MAX_LENGTH ? trim(ua, UA_MAX_LENGTH) : ua;
            return this;
          };
          this.setUA(_ua);
          return this;
        };
        UAParser.VERSION = LIBVERSION;
        UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR]);
        UAParser.CPU = enumerize([ARCHITECTURE]);
        UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
        UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);

        ///////////
        // Export
        //////////

        // check js environment
        {
          // nodejs env
          if (module.exports) {
            exports = module.exports = UAParser;
          }
          exports.UAParser = UAParser;
        }

        // jQuery/Zepto specific (optional)
        // Note:
        //   In AMD env the global scope should be kept clean, but jQuery is an exception.
        //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
        //   and we should catch that.
        var $ = typeof window !== UNDEF_TYPE && (window.jQuery || window.Zepto);
        if ($ && !$.ua) {
          var parser = new UAParser();
          $.ua = parser.getResult();
          $.ua.get = function () {
            return parser.getUA();
          };
          $.ua.set = function (ua) {
            parser.setUA(ua);
            var result = parser.getResult();
            for (var prop in result) {
              $.ua[prop] = result[prop];
            }
          };
        }
      })(typeof window === 'object' ? window : commonjsGlobal);
    })(uaParser, uaParser.exports);
    var uaParserExports = uaParser.exports;
    var UAParser = /*@__PURE__*/getDefaultExportFromCjs(uaParserExports);

    const computeScreenSize = screenWidth => {
      if (screenWidth <= 768) return 'small';else if (screenWidth > 768 && screenWidth <= 1024) return 'medium';else if (screenWidth > 1024) return 'large';
      return 'unknown';
    };
    const computeNetworkType = networkInformation => {
      var _a;
      return (_a = networkInformation === null || networkInformation === void 0 ? void 0 : networkInformation.effectiveType) !== null && _a !== void 0 ? _a : 'unknown';
    };
    const computeDeviceType = (detectedDeviceType, detectedBrowserName) => {
      // ua-parser-js doesn't fill in device type unless it's in the user agent directly
      // which means that desktops/laptops show up as undefined
      // https://github.com/faisalman/ua-parser-js/issues/182
      //
      // we're going to do this:
      // browser name & device type both undefined -> unknown
      // browser name defined & device type undefined -> desktop
      // device type defined -> use that
      if (!detectedDeviceType && !detectedBrowserName) {
        return 'unknown';
      }
      if (!detectedDeviceType) {
        return 'desktop';
      }
      return detectedDeviceType;
    };
    const computeDeviceProperties = userAgent => {
      const uaParser = new UAParser(userAgent);
      const {
        name: browserName,
        version: browserVersion
      } = uaParser.getBrowser();
      return {
        browserName: browserName !== null && browserName !== void 0 ? browserName : 'unknown',
        browserVersion: browserVersion !== null && browserVersion !== void 0 ? browserVersion : 'unknown',
        deviceType: computeDeviceType(uaParser.getDevice().type, browserName)
      };
    };
    function configureBrowserAttributesResource() {
      const {
        browserName,
        browserVersion,
        deviceType
      } = computeDeviceProperties(navigator.userAgent);
      return new Resource({
        'user_agent.original': navigator.userAgent,
        //https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#mobile_tablet_or_desktop
        'browser.mobile': navigator.userAgent.includes('Mobi'),
        'browser.touch_screen_enabled': navigator.maxTouchPoints > 0,
        'browser.language': navigator.language,
        'browser.name': browserName,
        'browser.version': browserVersion,
        'device.type': deviceType,
        'network.effectiveType': computeNetworkType(navigator.connection),
        'screen.width': window.screen.width,
        'screen.height': window.screen.height,
        'screen.size': computeScreenSize(window.screen.width)
      });
    }

    /* Takes an array of resources and merges into one mega-resource */
    function mergeResources(resources) {
      let mergedResources = validateResource(resources[0]);
      for (let i = 1; i < resources.length; i++) {
        if (!resources[i]) {
          continue;
        }
        const resource = validateResource(resources[i]);
        mergedResources = mergedResources.merge(resource);
      }
      return mergedResources;
    }
    function validateResource(resource) {
      if (resource instanceof Resource) {
        return resource;
      }
      if (resource) {
        return new Resource(resource);
      }
      return new Resource({});
    }

    // Constants
    const DEFAULT_API_ENDPOINT = 'https://api.honeycomb.io';
    const TRACES_PATH = 'v1/traces';
    const DEFAULT_TRACES_ENDPOINT = `${DEFAULT_API_ENDPOINT}/${TRACES_PATH}`;
    const DEFAULT_SERVICE_NAME = 'unknown_service';
    const DEFAULT_SAMPLE_RATE = 1;
    /**
     * Default options for the Honeycomb Web SDK.
     */
    const defaultOptions = {
      apiKey: '',
      tracesApiKey: '',
      endpoint: DEFAULT_TRACES_ENDPOINT,
      tracesEndpoint: DEFAULT_TRACES_ENDPOINT,
      serviceName: DEFAULT_SERVICE_NAME,
      debug: false,
      sampleRate: 1,
      skipOptionsValidation: false,
      localVisualizations: false,
      webVitalsInstrumentationConfig: {
        enabled: true
      }
    };
    const createHoneycombSDKLogMessage = message => `@honeycombio/opentelemetry-web: ${message}`;
    const classicKeyRegex = /^[a-f0-9]*$/;
    const ingestClassicKeyRegex = /^hc[a-z]ic_[a-z0-9]*$/;
    /**
     * Determines whether the passed in apikey is classic or not.
     *
     * @param apikey the apikey
     * @returns a boolean to indicate if the apikey was a classic key
     */
    function isClassic(apikey) {
      if (apikey == null || apikey.length === 0) {
        return false;
      } else if (apikey.length === 32) {
        return classicKeyRegex.test(apikey);
      } else if (apikey.length === 64) {
        return ingestClassicKeyRegex.test(apikey);
      }
      return false;
    }
    /**
     * Checks for and appends v1/traces to provided URL if missing when using an HTTP
     * based exporter protocol.
     *
     * @param url the base URL to append traces path to if missing
     * @returns the endpoint with traces path appended if missing
     */
    function maybeAppendTracesPath(url) {
      if (url.endsWith(TRACES_PATH) || url.endsWith(`${TRACES_PATH}/`)) {
        return url;
      }
      return url.endsWith('/') ? url + TRACES_PATH : url + '/' + TRACES_PATH;
    }
    const getTracesEndpoint = options => {
      // use `tracesEndpoint` option unchanged if provided
      if (options === null || options === void 0 ? void 0 : options.tracesEndpoint) {
        return options.tracesEndpoint;
      }
      // use `endpoint` option if provided and append '/v1/traces' if not already appended
      if (options === null || options === void 0 ? void 0 : options.endpoint) {
        return maybeAppendTracesPath(options.endpoint);
      }
      return DEFAULT_TRACES_ENDPOINT;
    };
    const getTracesApiKey = options => {
      return (options === null || options === void 0 ? void 0 : options.tracesApiKey) || (options === null || options === void 0 ? void 0 : options.apiKey);
    };
    const getSampleRate = options => {
      if (
      // must be a whole positive integer
      typeof (options === null || options === void 0 ? void 0 : options.sampleRate) === 'number' && Number.isSafeInteger(options === null || options === void 0 ? void 0 : options.sampleRate) && (options === null || options === void 0 ? void 0 : options.sampleRate) >= 0) {
        return options === null || options === void 0 ? void 0 : options.sampleRate;
      }
      return DEFAULT_SAMPLE_RATE;
    };

    const MISSING_API_KEY_ERROR = createHoneycombSDKLogMessage('❌ Missing API Key. Set `apiKey` in HoneycombOptions. Telemetry will not be exported.');
    const MISSING_SERVICE_NAME_ERROR = createHoneycombSDKLogMessage(`❌ Missing Service Name. Set \`serviceName\` in HoneycombOptions. Defaulting to '${defaultOptions.serviceName}'`);
    const IGNORED_DATASET_ERROR = createHoneycombSDKLogMessage('🔕 Dataset is ignored in favor of service name.');
    const MISSING_DATASET_ERROR = createHoneycombSDKLogMessage('❌ Missing dataset. Specify either HONEYCOMB_DATASET environment variable or dataset in the options parameter.');
    const SKIPPING_OPTIONS_VALIDATION_MSG = createHoneycombSDKLogMessage('⏭️ Skipping options validation. To re-enable, set skipOptionsValidation option or HONEYCOMB_SKIP_OPTIONS_VALIDATION to false.');
    const SAMPLER_OVERRIDE_WARNING = createHoneycombSDKLogMessage('🔨 Default deterministic sampler has been overridden. Honeycomb requires a resource attribute called SampleRate to properly show weighted values. Non-deterministic sampleRate could lead to missing spans in Honeycomb. See our docs for more details. https://docs.honeycomb.io/getting-data-in/opentelemetry/node-distro/#sampling-without-the-honeycomb-sdk');
    const MISSING_FIELDS_FOR_LOCAL_VISUALIZATIONS = createHoneycombSDKLogMessage('🔕 Disabling local visualizations - must have both service name and API key configured.');
    const FAILED_AUTH_FOR_LOCAL_VISUALIZATIONS = createHoneycombSDKLogMessage('🔕 Failed to get proper auth response from Honeycomb. No local visualization available.');
    const validateOptionsWarnings = options => {
      if (options === null || options === void 0 ? void 0 : options.skipOptionsValidation) {
        console.debug(SKIPPING_OPTIONS_VALIDATION_MSG);
        return;
      }
      // warn if api key is missing
      if (!(options === null || options === void 0 ? void 0 : options.apiKey)) {
        console.warn(MISSING_API_KEY_ERROR);
      }
      // warn if service name is missing
      if (!(options === null || options === void 0 ? void 0 : options.serviceName)) {
        console.warn(MISSING_SERVICE_NAME_ERROR);
      }
      // warn if dataset is set while using an environment-aware key
      if ((options === null || options === void 0 ? void 0 : options.apiKey) && !isClassic(options === null || options === void 0 ? void 0 : options.apiKey) && (options === null || options === void 0 ? void 0 : options.dataset)) {
        console.warn(IGNORED_DATASET_ERROR);
      }
      // warn if dataset is missing if using classic key
      if ((options === null || options === void 0 ? void 0 : options.apiKey) && isClassic(options === null || options === void 0 ? void 0 : options.apiKey) && !(options === null || options === void 0 ? void 0 : options.dataset)) {
        console.warn(MISSING_DATASET_ERROR);
      }
      // warn if custom sampler provided
      if (options === null || options === void 0 ? void 0 : options.sampler) {
        console.debug(SAMPLER_OVERRIDE_WARNING);
      }
      return options;
    };

    /**
     * Configures the Honeycomb Web SDK to log debug information to the console.
     * Enables the DiagConsoleLogger and sets the log level to DEBUG.
     * Logs the provided Honeycomb options to the console, as well as defaults.
     *
     * @param options the provided Honeycomb options
     */
    function configureDebug(options) {
      if (!(options === null || options === void 0 ? void 0 : options.debug)) {
        return;
      }
      diag.setLogger(new DiagConsoleLogger(), DiagLogLevel.DEBUG);
      diag.debug(createHoneycombSDKLogMessage('🐝 Honeycomb Web SDK Debug Mode Enabled 🐝'));
      // traces endpoint must be computed from provided options
      const tracesEndpoint = getTracesEndpoint(options);
      const currentOptions = Object.assign(Object.assign(Object.assign({}, defaultOptions), options), {
        tracesEndpoint
      });
      debugTracesApiKey(currentOptions);
      debugServiceName(currentOptions);
      debugTracesEndpoint(currentOptions);
      debugSampleRate(currentOptions);
    }
    function debugTracesApiKey(options) {
      const tracesApiKey = getTracesApiKey(options) || '';
      if (!tracesApiKey) {
        diag.debug(MISSING_API_KEY_ERROR);
        return;
      }
      diag.debug(createHoneycombSDKLogMessage(`API Key configured for traces: '${tracesApiKey}'`));
    }
    function debugServiceName(options) {
      const serviceName = options.serviceName || defaultOptions.serviceName;
      if (serviceName === defaultOptions.serviceName) {
        diag.debug(MISSING_SERVICE_NAME_ERROR);
        return;
      }
      diag.debug(`@honeycombio/opentelemetry-web: Service Name configured for traces: '${serviceName}'`);
    }
    function debugTracesEndpoint(options) {
      const tracesEndpoint = getTracesEndpoint(options);
      if (!tracesEndpoint) {
        diag.debug(createHoneycombSDKLogMessage('No endpoint configured for traces'));
        return;
      }
      diag.debug(createHoneycombSDKLogMessage(`Endpoint configured for traces: '${tracesEndpoint}'`));
    }
    function debugSampleRate(options) {
      const sampleRate = getSampleRate(options);
      if (!sampleRate) {
        // this should never happen, but guard just in case?
        diag.debug('No sampler configured for traces');
        return;
      }
      diag.debug(createHoneycombSDKLogMessage(`Sample Rate configured for traces: '${sampleRate}'`));
    }

    /**
     * A {@link SpanProcessor} that reads entries stored in {@link Baggage}
     * from the parent context and adds the baggage entries' keys and values
     * to the span as attributes on span start.
     *
     * Keys and values added to Baggage will appear on subsequent child
     * spans for a trace within this service *and* be propagated to external
     * services in accordance with any configured propagation formats
     * configured. If the external services also have a Baggage span
     * processor, the keys and values will appear in those child spans as
     * well.
     *
     * ⚠ Warning ⚠️
     *
     * Do not put sensitive information in Baggage.
     *
     * To repeat: a consequence of adding data to Baggage is that the keys and
     * values will appear in all outgoing HTTP headers from the application.
     */
    class BaggageSpanProcessor {
      constructor() {}
      onStart(span, parentContext) {
        var _a, _b;
        ((_b = (_a = propagation.getBaggage(parentContext)) === null || _a === void 0 ? void 0 : _a.getAllEntries()) !== null && _b !== void 0 ? _b : []).forEach(entry => {
          span.setAttribute(entry[0], entry[1].value);
          diag.debug(`@honeycombio/opentelemetry-web: 🚨 Baggage in all outgoing headers: ${entry[0]}=${entry[1].value} `);
        });
      }
      onEnd() {}
      forceFlush() {
        return Promise.resolve();
      }
      shutdown() {
        return Promise.resolve();
      }
    }

    /**
     * A {@link SpanProcessor} that adds browser specific attributes to each span
     * that might change over the course of a session.
     * Static attributes (e.g. User Agent) are added to the Resource.
     */
    class BrowserAttributesSpanProcessor {
      constructor() {}
      onStart(span) {
        const {
          href,
          pathname,
          search,
          hash,
          hostname
        } = window.location;
        span.setAttributes({
          'browser.width': window.innerWidth,
          'browser.height': window.innerHeight,
          'page.hash': hash,
          'page.url': href,
          'page.route': pathname,
          'page.hostname': hostname,
          'page.search': search,
          'url.path': pathname
        });
      }
      onEnd() {}
      forceFlush() {
        return Promise.resolve();
      }
      shutdown() {
        return Promise.resolve();
      }
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __read$3 = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var DEFAULT_TRACE_TIMEOUT = 10000;
    var DEFAULT_EXPORT_MAX_ATTEMPTS = 5;
    var DEFAULT_EXPORT_INITIAL_BACKOFF = 1000;
    var DEFAULT_EXPORT_MAX_BACKOFF = 5000;
    var DEFAULT_EXPORT_BACKOFF_MULTIPLIER = 1.5;
    /**
     * Parses headers from config leaving only those that have defined values
     * @param partialHeaders
     */
    function parseHeaders(partialHeaders) {
      if (partialHeaders === void 0) {
        partialHeaders = {};
      }
      var headers = {};
      Object.entries(partialHeaders).forEach(function (_a) {
        var _b = __read$3(_a, 2),
          key = _b[0],
          value = _b[1];
        if (typeof value !== 'undefined') {
          headers[key] = String(value);
        } else {
          diag.warn("Header \"" + key + "\" has invalid value (" + value + ") and will be ignored");
        }
      });
      return headers;
    }
    /**
     * Adds path (version + signal) to a no per-signal endpoint
     * @param url
     * @param path
     * @returns url + path
     */
    function appendResourcePathToUrl(url, path) {
      if (!url.endsWith('/')) {
        url = url + '/';
      }
      return url + path;
    }
    /**
     * Adds root path to signal specific endpoint when endpoint contains no path part and no root path
     * @param url
     * @returns url
     */
    function appendRootPathToUrlIfNeeded(url) {
      try {
        var parsedUrl = new URL(url);
        if (parsedUrl.pathname === '') {
          parsedUrl.pathname = parsedUrl.pathname + '/';
        }
        return parsedUrl.toString();
      } catch (_a) {
        diag.warn("Could not parse export URL: '" + url + "'");
        return url;
      }
    }
    /**
     * Configure exporter trace timeout value from passed in value or environment variables
     * @param timeoutMillis
     * @returns timeout value in milliseconds
     */
    function configureExporterTimeout(timeoutMillis) {
      if (typeof timeoutMillis === 'number') {
        if (timeoutMillis <= 0) {
          // OTLP exporter configured timeout - using default value of 10000ms
          return invalidTimeout(timeoutMillis, DEFAULT_TRACE_TIMEOUT);
        }
        return timeoutMillis;
      } else {
        return getExporterTimeoutFromEnv();
      }
    }
    function getExporterTimeoutFromEnv() {
      var _a;
      var definedTimeout = Number((_a = getEnv().OTEL_EXPORTER_OTLP_TRACES_TIMEOUT) !== null && _a !== void 0 ? _a : getEnv().OTEL_EXPORTER_OTLP_TIMEOUT);
      if (definedTimeout <= 0) {
        // OTLP exporter configured timeout - using default value of 10000ms
        return invalidTimeout(definedTimeout, DEFAULT_TRACE_TIMEOUT);
      } else {
        return definedTimeout;
      }
    }
    // OTLP exporter configured timeout - using default value of 10000ms
    function invalidTimeout(timeout, defaultTimeout) {
      diag.warn('Timeout must be greater than 0', timeout);
      return defaultTimeout;
    }
    function isExportRetryable(statusCode) {
      var retryCodes = [429, 502, 503, 504];
      return retryCodes.includes(statusCode);
    }
    function parseRetryAfterToMills(retryAfter) {
      if (retryAfter == null) {
        return -1;
      }
      var seconds = Number.parseInt(retryAfter, 10);
      if (Number.isInteger(seconds)) {
        return seconds > 0 ? seconds * 1000 : -1;
      }
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After#directives
      var delay = new Date(retryAfter).getTime() - Date.now();
      if (delay >= 0) {
        return delay;
      }
      return 0;
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Collector Exporter abstract base class
     */
    var OTLPExporterBase = /** @class */function () {
      /**
       * @param config
       */
      function OTLPExporterBase(config) {
        if (config === void 0) {
          config = {};
        }
        this._sendingPromises = [];
        this.url = this.getDefaultUrl(config);
        if (typeof config.hostname === 'string') {
          this.hostname = config.hostname;
        }
        this.shutdown = this.shutdown.bind(this);
        this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
        this._concurrencyLimit = typeof config.concurrencyLimit === 'number' ? config.concurrencyLimit : 30;
        this.timeoutMillis = configureExporterTimeout(config.timeoutMillis);
        // platform dependent
        this.onInit(config);
      }
      /**
       * Export items.
       * @param items
       * @param resultCallback
       */
      OTLPExporterBase.prototype.export = function (items, resultCallback) {
        if (this._shutdownOnce.isCalled) {
          resultCallback({
            code: ExportResultCode.FAILED,
            error: new Error('Exporter has been shutdown')
          });
          return;
        }
        if (this._sendingPromises.length >= this._concurrencyLimit) {
          resultCallback({
            code: ExportResultCode.FAILED,
            error: new Error('Concurrent export limit reached')
          });
          return;
        }
        this._export(items).then(function () {
          resultCallback({
            code: ExportResultCode.SUCCESS
          });
        }).catch(function (error) {
          resultCallback({
            code: ExportResultCode.FAILED,
            error: error
          });
        });
      };
      OTLPExporterBase.prototype._export = function (items) {
        var _this = this;
        return new Promise(function (resolve, reject) {
          try {
            diag.debug('items to be sent', items);
            _this.send(items, resolve, reject);
          } catch (e) {
            reject(e);
          }
        });
      };
      /**
       * Shutdown the exporter.
       */
      OTLPExporterBase.prototype.shutdown = function () {
        return this._shutdownOnce.call();
      };
      /**
       * Exports any pending spans in the exporter
       */
      OTLPExporterBase.prototype.forceFlush = function () {
        return Promise.all(this._sendingPromises).then(function () {
          /** ignore resolved values */
        });
      };
      /**
       * Called by _shutdownOnce with BindOnceFuture
       */
      OTLPExporterBase.prototype._shutdown = function () {
        diag.debug('shutdown started');
        this.onShutdown();
        return this.forceFlush();
      };
      return OTLPExporterBase;
    }();

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __extends$2 = undefined && undefined.__extends || function () {
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    /**
     * Interface for handling error
     */
    var OTLPExporterError = /** @class */function (_super) {
      __extends$2(OTLPExporterError, _super);
      function OTLPExporterError(message, code, data) {
        var _this = _super.call(this, message) || this;
        _this.name = 'OTLPExporterError';
        _this.data = data;
        _this.code = code;
        return _this;
      }
      return OTLPExporterError;
    }(Error);

    var __assign$1 = undefined && undefined.__assign || function () {
      __assign$1 = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign$1.apply(this, arguments);
    };
    var __read$2 = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    /**
     * Send metrics/spans using browser navigator.sendBeacon
     * @param body
     * @param url
     * @param blobPropertyBag
     * @param onSuccess
     * @param onError
     */
    function sendWithBeacon(body, url, blobPropertyBag, onSuccess, onError) {
      if (navigator.sendBeacon(url, new Blob([body], blobPropertyBag))) {
        diag.debug('sendBeacon - can send', body);
        onSuccess();
      } else {
        var error = new OTLPExporterError("sendBeacon - cannot send " + body);
        onError(error);
      }
    }
    /**
     * function to send metrics/spans using browser XMLHttpRequest
     *     used when navigator.sendBeacon is not available
     * @param body
     * @param url
     * @param headers
     * @param onSuccess
     * @param onError
     */
    function sendWithXhr(body, url, headers, exporterTimeout, onSuccess, onError) {
      var retryTimer;
      var xhr;
      var reqIsDestroyed = false;
      var exporterTimer = setTimeout(function () {
        clearTimeout(retryTimer);
        reqIsDestroyed = true;
        if (xhr.readyState === XMLHttpRequest.DONE) {
          var err = new OTLPExporterError('Request Timeout');
          onError(err);
        } else {
          xhr.abort();
        }
      }, exporterTimeout);
      var sendWithRetry = function (retries, minDelay) {
        if (retries === void 0) {
          retries = DEFAULT_EXPORT_MAX_ATTEMPTS;
        }
        if (minDelay === void 0) {
          minDelay = DEFAULT_EXPORT_INITIAL_BACKOFF;
        }
        xhr = new XMLHttpRequest();
        xhr.open('POST', url);
        var defaultHeaders = {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        };
        Object.entries(__assign$1(__assign$1({}, defaultHeaders), headers)).forEach(function (_a) {
          var _b = __read$2(_a, 2),
            k = _b[0],
            v = _b[1];
          xhr.setRequestHeader(k, v);
        });
        xhr.send(body);
        xhr.onreadystatechange = function () {
          if (xhr.readyState === XMLHttpRequest.DONE && reqIsDestroyed === false) {
            if (xhr.status >= 200 && xhr.status <= 299) {
              diag.debug('xhr success', body);
              onSuccess();
              clearTimeout(exporterTimer);
              clearTimeout(retryTimer);
            } else if (xhr.status && isExportRetryable(xhr.status) && retries > 0) {
              var retryTime = void 0;
              minDelay = DEFAULT_EXPORT_BACKOFF_MULTIPLIER * minDelay;
              // retry after interval specified in Retry-After header
              if (xhr.getResponseHeader('Retry-After')) {
                retryTime = parseRetryAfterToMills(xhr.getResponseHeader('Retry-After'));
              } else {
                // exponential backoff with jitter
                retryTime = Math.round(Math.random() * (DEFAULT_EXPORT_MAX_BACKOFF - minDelay) + minDelay);
              }
              retryTimer = setTimeout(function () {
                sendWithRetry(retries - 1, minDelay);
              }, retryTime);
            } else {
              var error = new OTLPExporterError("Failed to export with XHR (status: " + xhr.status + ")", xhr.status);
              onError(error);
              clearTimeout(exporterTimer);
              clearTimeout(retryTimer);
            }
          }
        };
        xhr.onabort = function () {
          if (reqIsDestroyed) {
            var err = new OTLPExporterError('Request Timeout');
            onError(err);
          }
          clearTimeout(exporterTimer);
          clearTimeout(retryTimer);
        };
        xhr.onerror = function () {
          if (reqIsDestroyed) {
            var err = new OTLPExporterError('Request Timeout');
            onError(err);
          }
          clearTimeout(exporterTimer);
          clearTimeout(retryTimer);
        };
      };
      sendWithRetry();
    }

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __extends$1 = undefined && undefined.__extends || function () {
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = undefined && undefined.__assign || function () {
      __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    /**
     * Collector Metric Exporter abstract base class
     */
    var OTLPExporterBrowserBase = /** @class */function (_super) {
      __extends$1(OTLPExporterBrowserBase, _super);
      /**
       * @param config
       * @param serializer
       * @param contentType
       */
      function OTLPExporterBrowserBase(config, serializer, contentType) {
        if (config === void 0) {
          config = {};
        }
        var _this = _super.call(this, config) || this;
        _this._useXHR = false;
        _this._serializer = serializer;
        _this._contentType = contentType;
        _this._useXHR = !!config.headers || typeof navigator.sendBeacon !== 'function';
        if (_this._useXHR) {
          _this._headers = Object.assign({}, parseHeaders(config.headers), parseKeyPairsIntoRecord(getEnv().OTEL_EXPORTER_OTLP_HEADERS));
        } else {
          _this._headers = {};
        }
        return _this;
      }
      OTLPExporterBrowserBase.prototype.onInit = function () {};
      OTLPExporterBrowserBase.prototype.onShutdown = function () {};
      OTLPExporterBrowserBase.prototype.send = function (items, onSuccess, onError) {
        var _this = this;
        var _a;
        if (this._shutdownOnce.isCalled) {
          diag.debug('Shutdown already started. Cannot send objects');
          return;
        }
        var body = (_a = this._serializer.serializeRequest(items)) !== null && _a !== void 0 ? _a : new Uint8Array();
        var promise = new Promise(function (resolve, reject) {
          if (_this._useXHR) {
            sendWithXhr(body, _this.url, __assign(__assign({}, _this._headers), {
              'Content-Type': _this._contentType
            }), _this.timeoutMillis, resolve, reject);
          } else {
            sendWithBeacon(body, _this.url, {
              type: _this._contentType
            }, resolve, reject);
          }
        }).then(onSuccess, onError);
        this._sendingPromises.push(promise);
        var popPromise = function () {
          var index = _this._sendingPromises.indexOf(promise);
          _this._sendingPromises.splice(index, 1);
        };
        promise.then(popPromise, popPromise);
      };
      return OTLPExporterBrowserBase;
    }(OTLPExporterBase);

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function hrTimeToNanos(hrTime) {
      var NANOSECONDS = BigInt(1000000000);
      return BigInt(hrTime[0]) * NANOSECONDS + BigInt(hrTime[1]);
    }
    function toLongBits(value) {
      var low = Number(BigInt.asUintN(32, value));
      var high = Number(BigInt.asUintN(32, value >> BigInt(32)));
      return {
        low: low,
        high: high
      };
    }
    function encodeAsLongBits(hrTime) {
      var nanos = hrTimeToNanos(hrTime);
      return toLongBits(nanos);
    }
    function encodeAsString(hrTime) {
      var nanos = hrTimeToNanos(hrTime);
      return nanos.toString();
    }
    var encodeTimestamp = typeof BigInt !== 'undefined' ? encodeAsString : hrTimeToNanoseconds;
    function identity(value) {
      return value;
    }
    function optionalHexToBinary(str) {
      if (str === undefined) return undefined;
      return hexToBinary(str);
    }
    var DEFAULT_ENCODER = {
      encodeHrTime: encodeAsLongBits,
      encodeSpanContext: hexToBinary,
      encodeOptionalSpanContext: optionalHexToBinary
    };
    function getOtlpEncoder(options) {
      var _a, _b;
      if (options === undefined) {
        return DEFAULT_ENCODER;
      }
      var useLongBits = (_a = options.useLongBits) !== null && _a !== void 0 ? _a : true;
      var useHex = (_b = options.useHex) !== null && _b !== void 0 ? _b : false;
      return {
        encodeHrTime: useLongBits ? encodeAsLongBits : encodeTimestamp,
        encodeSpanContext: useHex ? identity : hexToBinary,
        encodeOptionalSpanContext: useHex ? identity : optionalHexToBinary
      };
    }

    var __read$1 = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    function createInstrumentationScope(scope) {
      return {
        name: scope.name,
        version: scope.version
      };
    }
    function toAttributes(attributes) {
      return Object.keys(attributes).map(function (key) {
        return toKeyValue(key, attributes[key]);
      });
    }
    function toKeyValue(key, value) {
      return {
        key: key,
        value: toAnyValue(value)
      };
    }
    function toAnyValue(value) {
      var t = typeof value;
      if (t === 'string') return {
        stringValue: value
      };
      if (t === 'number') {
        if (!Number.isInteger(value)) return {
          doubleValue: value
        };
        return {
          intValue: value
        };
      }
      if (t === 'boolean') return {
        boolValue: value
      };
      if (value instanceof Uint8Array) return {
        bytesValue: value
      };
      if (Array.isArray(value)) return {
        arrayValue: {
          values: value.map(toAnyValue)
        }
      };
      if (t === 'object' && value != null) return {
        kvlistValue: {
          values: Object.entries(value).map(function (_a) {
            var _b = __read$1(_a, 2),
              k = _b[0],
              v = _b[1];
            return toKeyValue(k, v);
          })
        }
      };
      return {};
    }

    function sdkSpanToOtlpSpan(span, encoder) {
      var _a;
      var ctx = span.spanContext();
      var status = span.status;
      return {
        traceId: encoder.encodeSpanContext(ctx.traceId),
        spanId: encoder.encodeSpanContext(ctx.spanId),
        parentSpanId: encoder.encodeOptionalSpanContext(span.parentSpanId),
        traceState: (_a = ctx.traceState) === null || _a === void 0 ? void 0 : _a.serialize(),
        name: span.name,
        // Span kind is offset by 1 because the API does not define a value for unset
        kind: span.kind == null ? 0 : span.kind + 1,
        startTimeUnixNano: encoder.encodeHrTime(span.startTime),
        endTimeUnixNano: encoder.encodeHrTime(span.endTime),
        attributes: toAttributes(span.attributes),
        droppedAttributesCount: span.droppedAttributesCount,
        events: span.events.map(function (event) {
          return toOtlpSpanEvent(event, encoder);
        }),
        droppedEventsCount: span.droppedEventsCount,
        status: {
          // API and proto enums share the same values
          code: status.code,
          message: status.message
        },
        links: span.links.map(function (link) {
          return toOtlpLink(link, encoder);
        }),
        droppedLinksCount: span.droppedLinksCount
      };
    }
    function toOtlpLink(link, encoder) {
      var _a;
      return {
        attributes: link.attributes ? toAttributes(link.attributes) : [],
        spanId: encoder.encodeSpanContext(link.context.spanId),
        traceId: encoder.encodeSpanContext(link.context.traceId),
        traceState: (_a = link.context.traceState) === null || _a === void 0 ? void 0 : _a.serialize(),
        droppedAttributesCount: link.droppedAttributesCount || 0
      };
    }
    function toOtlpSpanEvent(timedEvent, encoder) {
      return {
        attributes: timedEvent.attributes ? toAttributes(timedEvent.attributes) : [],
        name: timedEvent.name,
        timeUnixNano: encoder.encodeHrTime(timedEvent.time),
        droppedAttributesCount: timedEvent.droppedAttributesCount || 0
      };
    }

    function createResource(resource) {
      return {
        attributes: toAttributes(resource.attributes),
        droppedAttributesCount: 0
      };
    }

    var __values = undefined && undefined.__values || function (o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function () {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = undefined && undefined.__read || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    function createExportTraceServiceRequest(spans, options) {
      var encoder = getOtlpEncoder(options);
      return {
        resourceSpans: spanRecordsToResourceSpans(spans, encoder)
      };
    }
    function createResourceMap(readableSpans) {
      var e_1, _a;
      var resourceMap = new Map();
      try {
        for (var readableSpans_1 = __values(readableSpans), readableSpans_1_1 = readableSpans_1.next(); !readableSpans_1_1.done; readableSpans_1_1 = readableSpans_1.next()) {
          var record = readableSpans_1_1.value;
          var ilmMap = resourceMap.get(record.resource);
          if (!ilmMap) {
            ilmMap = new Map();
            resourceMap.set(record.resource, ilmMap);
          }
          // TODO this is duplicated in basic tracer. Consolidate on a common helper in core
          var instrumentationLibraryKey = record.instrumentationLibrary.name + "@" + (record.instrumentationLibrary.version || '') + ":" + (record.instrumentationLibrary.schemaUrl || '');
          var records = ilmMap.get(instrumentationLibraryKey);
          if (!records) {
            records = [];
            ilmMap.set(instrumentationLibraryKey, records);
          }
          records.push(record);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (readableSpans_1_1 && !readableSpans_1_1.done && (_a = readableSpans_1.return)) _a.call(readableSpans_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return resourceMap;
    }
    function spanRecordsToResourceSpans(readableSpans, encoder) {
      var resourceMap = createResourceMap(readableSpans);
      var out = [];
      var entryIterator = resourceMap.entries();
      var entry = entryIterator.next();
      while (!entry.done) {
        var _a = __read(entry.value, 2),
          resource = _a[0],
          ilmMap = _a[1];
        var scopeResourceSpans = [];
        var ilmIterator = ilmMap.values();
        var ilmEntry = ilmIterator.next();
        while (!ilmEntry.done) {
          var scopeSpans = ilmEntry.value;
          if (scopeSpans.length > 0) {
            var spans = scopeSpans.map(function (readableSpan) {
              return sdkSpanToOtlpSpan(readableSpan, encoder);
            });
            scopeResourceSpans.push({
              scope: createInstrumentationScope(scopeSpans[0].instrumentationLibrary),
              spans: spans,
              schemaUrl: scopeSpans[0].instrumentationLibrary.schemaUrl
            });
          }
          ilmEntry = ilmIterator.next();
        }
        // TODO SDK types don't provide resource schema URL at this time
        var transformedSpans = {
          resource: createResource(resource),
          scopeSpans: scopeResourceSpans,
          schemaUrl: undefined
        };
        out.push(transformedSpans);
        entry = entryIterator.next();
      }
      return out;
    }

    var JsonTraceSerializer = {
      serializeRequest: function (arg) {
        var request = createExportTraceServiceRequest(arg, {
          useHex: true,
          useLongBits: false
        });
        var encoder = new TextEncoder();
        return encoder.encode(JSON.stringify(request));
      },
      deserializeResponse: function (arg) {
        var decoder = new TextDecoder();
        return JSON.parse(decoder.decode(arg));
      }
    };

    /*
     * Copyright The OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var __extends = undefined && undefined.__extends || function () {
      var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
      };
      return function (d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var DEFAULT_COLLECTOR_RESOURCE_PATH = 'v1/traces';
    var DEFAULT_COLLECTOR_URL = "http://localhost:4318/" + DEFAULT_COLLECTOR_RESOURCE_PATH;
    /**
     * Collector Trace Exporter for Web
     */
    var OTLPTraceExporter = /** @class */function (_super) {
      __extends(OTLPTraceExporter, _super);
      function OTLPTraceExporter(config) {
        if (config === void 0) {
          config = {};
        }
        var _this = _super.call(this, config, JsonTraceSerializer, 'application/json') || this;
        _this._headers = Object.assign(_this._headers, parseKeyPairsIntoRecord(getEnv().OTEL_EXPORTER_OTLP_TRACES_HEADERS));
        return _this;
      }
      OTLPTraceExporter.prototype.getDefaultUrl = function (config) {
        return typeof config.url === 'string' ? config.url : getEnv().OTEL_EXPORTER_OTLP_TRACES_ENDPOINT.length > 0 ? appendRootPathToUrlIfNeeded(getEnv().OTEL_EXPORTER_OTLP_TRACES_ENDPOINT) : getEnv().OTEL_EXPORTER_OTLP_ENDPOINT.length > 0 ? appendResourcePathToUrl(getEnv().OTEL_EXPORTER_OTLP_ENDPOINT, DEFAULT_COLLECTOR_RESOURCE_PATH) : DEFAULT_COLLECTOR_URL;
      };
      return OTLPTraceExporter;
    }(OTLPExporterBrowserBase);

    const TEAM_HEADER_KEY = 'x-honeycomb-team';
    const DATASET_HEADER_KEY = 'x-honeycomb-dataset';
    /**
     * Builds and returns an OTLP Traces exporter that sends data over http/json
     * @param options The {@link HoneycombOptions} used to configure the exporter
     * @returns a {@link SpanExporter} configured to send telemetry to Honeycomb over http/json
     */
    function configureHoneycombHttpJsonTraceExporter(options) {
      const apiKey = getTracesApiKey(options);
      return new OTLPTraceExporter({
        url: getTracesEndpoint(options),
        headers: Object.assign({
          [TEAM_HEADER_KEY]: apiKey,
          [DATASET_HEADER_KEY]: isClassic(apiKey) ? options === null || options === void 0 ? void 0 : options.dataset : undefined
        }, options === null || options === void 0 ? void 0 : options.headers)
      });
    }

    /**
     * Builds and returns a new {@link SpanExporter} that wraps the provided array
     * of {@link SpanExporter}s
     *
     * @param exporters the exporters to wrap with the composite exporter
     * @returns the configured {@link SpanExporter} instance
     */
    function configureCompositeExporter(exporters) {
      return new CompositeSpanExporter(exporters);
    }
    /**
     * A custom SpanExporter that wraps a number of other exporters and calls export and shutdown
     * for each.
     */
    class CompositeSpanExporter {
      constructor(exporters) {
        this._exporters = exporters;
      }
      export(spans, resultCallback) {
        this._exporters.forEach(exporter => exporter.export(spans, resultCallback));
        resultCallback({
          code: ExportResultCode.SUCCESS
        });
      }
      async shutdown() {
        const results = [];
        this._exporters.forEach(exporter => results.push(exporter.shutdown()));
        await Promise.all(results);
      }
    }

    /**
     * Builds and returns a {@link SpanExporter} that logs Honeycomb URLs for completed traces
     *
     * @remark This is not for production use.
     * @param options The {@link HoneycombOptions} used to configure the exporter
     * @returns the configured {@link ConsoleTraceLinkExporter} instance
     */
    function configureConsoleTraceLinkExporter(options) {
      const apiKey = getTracesApiKey(options);
      return new ConsoleTraceLinkExporter(options === null || options === void 0 ? void 0 : options.serviceName, apiKey);
    }
    /**
     * A custom {@link SpanExporter} that logs Honeycomb URLs for completed traces.
     *
     * @remark This is not for production use.
     */
    class ConsoleTraceLinkExporter {
      constructor(serviceName, apikey) {
        this._traceUrl = '';
        if (!serviceName || !apikey) {
          console.debug(MISSING_FIELDS_FOR_LOCAL_VISUALIZATIONS);
          return;
        }
        const options = {
          headers: {
            'x-honeycomb-team': apikey
          }
        };
        fetch('https://api.honeycomb.io/1/auth', options).then(resp => {
          if (resp.ok) {
            return resp.json();
          }
          throw new Error();
        }).then(data => {
          var _a, _b, _c;
          const respData = data;
          if ((_a = respData.team) === null || _a === void 0 ? void 0 : _a.slug) {
            this._traceUrl = buildTraceUrl(apikey, serviceName, (_b = respData.team) === null || _b === void 0 ? void 0 : _b.slug, (_c = respData.environment) === null || _c === void 0 ? void 0 : _c.slug);
          } else {
            throw new Error();
          }
        }).catch(() => {
          console.log(FAILED_AUTH_FOR_LOCAL_VISUALIZATIONS);
        });
      }
      export(spans, resultCallback) {
        if (this._traceUrl) {
          spans.forEach(span => {
            // only log root spans (ones without a parent span)
            if (!span.parentSpanId) {
              console.log(createHoneycombSDKLogMessage(`Honeycomb link: ${this._traceUrl}=${span.spanContext().traceId}`));
            }
          });
        }
        resultCallback({
          code: ExportResultCode.SUCCESS
        });
      }
      shutdown() {
        return Promise.resolve();
      }
    }
    /**
     * Builds and returns a URL that is used to log when a trace is completed in the {@link ConsoleTraceLinkExporter}.
     *
     * @param apikey the Honeycomb API key used to retrieve the Honeycomb team and environment
     * @param serviceName the Honeycomb service name (or classic dataset) where data is stored
     * @param team the Honeycomb team
     * @param environment the Honeycomb environment
     * @returns
     */
    function buildTraceUrl(apikey, serviceName, team, environment) {
      let url = `https://ui.honeycomb.io/${team}`;
      if (!isClassic(apikey) && environment) {
        url += `/environments/${environment}`;
      }
      url += `/datasets/${serviceName}/trace?trace_id`;
      return url;
    }

    /**
     * Builds and returns Span Processor that combines the BatchSpanProcessor, BrowserSpanProcessor,
     * BaggageSpanProcessor, and optionally a user provided Span Processor.
     * @param options The {@link HoneycombOptions}
     * @returns a {@link CompositeSpanProcessor}
     */
    const configureSpanProcessors = options => {
      const honeycombSpanProcessor = new CompositeSpanProcessor();
      const honeycombTraceExporters = [];
      if (options === null || options === void 0 ? void 0 : options.localVisualizations) {
        honeycombTraceExporters.push(configureConsoleTraceLinkExporter(options));
      }
      // if there is a user-provided exporter, add to the composite exporter
      if (options === null || options === void 0 ? void 0 : options.traceExporter) {
        honeycombTraceExporters.push(options === null || options === void 0 ? void 0 : options.traceExporter);
      }
      // We have to configure the exporter here because the way the base SDK is setup
      // does not allow having both a `spanProcessor` and `traceExporter` configured.
      honeycombSpanProcessor.addProcessor(new BatchSpanProcessor(configureCompositeExporter([configureHoneycombHttpJsonTraceExporter(options), ...honeycombTraceExporters])));
      // we always want to add the baggage span processor
      honeycombSpanProcessor.addProcessor(new BaggageSpanProcessor());
      // we always want to add the browser attrs span processor
      honeycombSpanProcessor.addProcessor(new BrowserAttributesSpanProcessor());
      // if there is a user provided span processor, add it to the composite span processor
      if (options === null || options === void 0 ? void 0 : options.spanProcessor) {
        honeycombSpanProcessor.addProcessor(options === null || options === void 0 ? void 0 : options.spanProcessor);
      }
      // if there is an array of spanProcessors provided, add them to the composite span processor
      if (options === null || options === void 0 ? void 0 : options.spanProcessors) {
        options.spanProcessors.forEach(processor => {
          honeycombSpanProcessor.addProcessor(processor);
        });
      }
      return honeycombSpanProcessor;
    };
    /**
     * A {@link SpanProcessor} that combines multiple span processors into a single
     * span processor that can be passed into the SDKs `spanProcessor` option.
     */
    class CompositeSpanProcessor {
      constructor() {
        this.spanProcessors = [];
      }
      addProcessor(processor) {
        this.spanProcessors.push(processor);
      }
      getSpanProcessors() {
        return this.spanProcessors;
      }
      onStart(span, parentContext) {
        this.spanProcessors.forEach(processor => {
          processor.onStart(span, parentContext);
        });
      }
      onEnd(span) {
        this.spanProcessors.forEach(processor => {
          processor.onEnd(span);
        });
      }
      forceFlush() {
        return Promise.all(this.spanProcessors.map(processor => processor.forceFlush())).then(() => {});
      }
      shutdown() {
        return Promise.all(this.spanProcessors.map(processor => processor.forceFlush())).then(() => {});
      }
    }

    /**
     * Builds and returns a Deterministic Sampler that uses the provided sample rate to
     * configure the inner sampler.
     * @param options The {@link HoneycombOptions}
     * @returns a {@link DeterministicSampler}
     */
    const configureDeterministicSampler = options => {
      const sampleRate = getSampleRate(options);
      return new DeterministicSampler(sampleRate);
    };
    /**
     * A {@link Sampler} that uses a deterministic sample rate to configure the sampler.
     */
    class DeterministicSampler {
      constructor(sampleRate) {
        this._sampleRate = sampleRate;
        switch (sampleRate) {
          // sample rate of 0 means send nothing
          case 0:
            this._sampler = new AlwaysOffSampler();
            break;
          // sample rate of 1 is default, send everything
          case 1:
            this._sampler = new AlwaysOnSampler();
            break;
          default:
            {
              const ratio = 1.0 / sampleRate;
              this._sampler = new TraceIdRatioBasedSampler(ratio);
              break;
            }
        }
      }
      shouldSample(context, traceId, spanName, spanKind, attributes, links) {
        const result = this._sampler.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        return Object.assign(Object.assign({}, result), {
          attributes: Object.assign(Object.assign({}, result.attributes), {
            SampleRate: this._sampleRate
          })
        });
      }
      toString() {
        return `DeterministicSampler(${this._sampler.toString()})`;
      }
    }

    var t,
      e,
      n = function () {
        var t = self.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0];
        if (t && t.responseStart > 0 && t.responseStart < performance.now()) return t;
      },
      r = function (t) {
        if ("loading" === document.readyState) return "loading";
        var e = n();
        if (e) {
          if (t < e.domInteractive) return "loading";
          if (0 === e.domContentLoadedEventStart || t < e.domContentLoadedEventStart) return "dom-interactive";
          if (0 === e.domComplete || t < e.domComplete) return "dom-content-loaded";
        }
        return "complete";
      },
      i = function (t) {
        var e = t.nodeName;
        return 1 === t.nodeType ? e.toLowerCase() : e.toUpperCase().replace(/^#/, "");
      },
      a = function (t, e) {
        var n = "";
        try {
          for (; t && 9 !== t.nodeType;) {
            var r = t,
              a = r.id ? "#" + r.id : i(r) + (r.classList && r.classList.value && r.classList.value.trim() && r.classList.value.trim().length ? "." + r.classList.value.trim().replace(/\s+/g, ".") : "");
            if (n.length + a.length > (e || 100) - 1) return n || a;
            if (n = n ? a + ">" + n : a, r.id) break;
            t = r.parentNode;
          }
        } catch (t) {}
        return n;
      },
      o = -1,
      c = function () {
        return o;
      },
      u = function (t) {
        addEventListener("pageshow", function (e) {
          e.persisted && (o = e.timeStamp, t(e));
        }, !0);
      },
      s = function () {
        var t = n();
        return t && t.activationStart || 0;
      },
      f = function (t, e) {
        var r = n(),
          i = "navigate";
        c() >= 0 ? i = "back-forward-cache" : r && (document.prerendering || s() > 0 ? i = "prerender" : document.wasDiscarded ? i = "restore" : r.type && (i = r.type.replace(/_/g, "-")));
        return {
          name: t,
          value: void 0 === e ? -1 : e,
          rating: "good",
          delta: 0,
          entries: [],
          id: "v4-".concat(Date.now(), "-").concat(Math.floor(8999999999999 * Math.random()) + 1e12),
          navigationType: i
        };
      },
      d = function (t, e, n) {
        try {
          if (PerformanceObserver.supportedEntryTypes.includes(t)) {
            var r = new PerformanceObserver(function (t) {
              Promise.resolve().then(function () {
                e(t.getEntries());
              });
            });
            return r.observe(Object.assign({
              type: t,
              buffered: !0
            }, n || {})), r;
          }
        } catch (t) {}
      },
      l = function (t, e, n, r) {
        var i, a;
        return function (o) {
          e.value >= 0 && (o || r) && ((a = e.value - (i || 0)) || void 0 === i) && (i = e.value, e.delta = a, e.rating = function (t, e) {
            return t > e[1] ? "poor" : t > e[0] ? "needs-improvement" : "good";
          }(e.value, n), t(e));
        };
      },
      m = function (t) {
        requestAnimationFrame(function () {
          return requestAnimationFrame(function () {
            return t();
          });
        });
      },
      p = function (t) {
        document.addEventListener("visibilitychange", function () {
          "hidden" === document.visibilityState && t();
        });
      },
      v = function (t) {
        var e = !1;
        return function () {
          e || (t(), e = !0);
        };
      },
      g = -1,
      h = function () {
        return "hidden" !== document.visibilityState || document.prerendering ? 1 / 0 : 0;
      },
      T = function (t) {
        "hidden" === document.visibilityState && g > -1 && (g = "visibilitychange" === t.type ? t.timeStamp : 0, E());
      },
      y = function () {
        addEventListener("visibilitychange", T, !0), addEventListener("prerenderingchange", T, !0);
      },
      E = function () {
        removeEventListener("visibilitychange", T, !0), removeEventListener("prerenderingchange", T, !0);
      },
      S = function () {
        return g < 0 && (g = h(), y(), u(function () {
          setTimeout(function () {
            g = h(), y();
          }, 0);
        })), {
          get firstHiddenTime() {
            return g;
          }
        };
      },
      b = function (t) {
        document.prerendering ? addEventListener("prerenderingchange", function () {
          return t();
        }, !0) : t();
      },
      L = [1800, 3e3],
      C = function (t, e) {
        e = e || {}, b(function () {
          var n,
            r = S(),
            i = f("FCP"),
            a = d("paint", function (t) {
              t.forEach(function (t) {
                "first-contentful-paint" === t.name && (a.disconnect(), t.startTime < r.firstHiddenTime && (i.value = Math.max(t.startTime - s(), 0), i.entries.push(t), n(!0)));
              });
            });
          a && (n = l(t, i, L, e.reportAllChanges), u(function (r) {
            i = f("FCP"), n = l(t, i, L, e.reportAllChanges), m(function () {
              i.value = performance.now() - r.timeStamp, n(!0);
            });
          }));
        });
      },
      M = [.1, .25],
      D = function (t, e) {
        !function (t, e) {
          e = e || {}, C(v(function () {
            var n,
              r = f("CLS", 0),
              i = 0,
              a = [],
              o = function (t) {
                t.forEach(function (t) {
                  if (!t.hadRecentInput) {
                    var e = a[0],
                      n = a[a.length - 1];
                    i && t.startTime - n.startTime < 1e3 && t.startTime - e.startTime < 5e3 ? (i += t.value, a.push(t)) : (i = t.value, a = [t]);
                  }
                }), i > r.value && (r.value = i, r.entries = a, n());
              },
              c = d("layout-shift", o);
            c && (n = l(t, r, M, e.reportAllChanges), p(function () {
              o(c.takeRecords()), n(!0);
            }), u(function () {
              i = 0, r = f("CLS", 0), n = l(t, r, M, e.reportAllChanges), m(function () {
                return n();
              });
            }), setTimeout(n, 0));
          }));
        }(function (e) {
          var n = function (t) {
            var e,
              n = {};
            if (t.entries.length) {
              var i = t.entries.reduce(function (t, e) {
                return t && t.value > e.value ? t : e;
              });
              if (i && i.sources && i.sources.length) {
                var o = (e = i.sources).find(function (t) {
                  return t.node && 1 === t.node.nodeType;
                }) || e[0];
                o && (n = {
                  largestShiftTarget: a(o.node),
                  largestShiftTime: i.startTime,
                  largestShiftValue: i.value,
                  largestShiftSource: o,
                  largestShiftEntry: i,
                  loadState: r(i.startTime)
                });
              }
            }
            return Object.assign(t, {
              attribution: n
            });
          }(e);
          t(n);
        }, e);
      },
      w = function (t, e) {
        C(function (e) {
          var i = function (t) {
            var e = {
              timeToFirstByte: 0,
              firstByteToFCP: t.value,
              loadState: r(c())
            };
            if (t.entries.length) {
              var i = n(),
                a = t.entries[t.entries.length - 1];
              if (i) {
                var o = i.activationStart || 0,
                  u = Math.max(0, i.responseStart - o);
                e = {
                  timeToFirstByte: u,
                  firstByteToFCP: t.value - u,
                  loadState: r(t.entries[0].startTime),
                  navigationEntry: i,
                  fcpEntry: a
                };
              }
            }
            return Object.assign(t, {
              attribution: e
            });
          }(e);
          t(i);
        }, e);
      },
      x = 0,
      I = 1 / 0,
      k = 0,
      A = function (t) {
        t.forEach(function (t) {
          t.interactionId && (I = Math.min(I, t.interactionId), k = Math.max(k, t.interactionId), x = k ? (k - I) / 7 + 1 : 0);
        });
      },
      F = function () {
        return t ? x : performance.interactionCount || 0;
      },
      P = function () {
        "interactionCount" in performance || t || (t = d("event", A, {
          type: "event",
          buffered: !0,
          durationThreshold: 0
        }));
      },
      B = [],
      O = new Map(),
      R = 0,
      j = function () {
        var t = Math.min(B.length - 1, Math.floor((F() - R) / 50));
        return B[t];
      },
      q = [],
      H = function (t) {
        if (q.forEach(function (e) {
          return e(t);
        }), t.interactionId || "first-input" === t.entryType) {
          var e = B[B.length - 1],
            n = O.get(t.interactionId);
          if (n || B.length < 10 || t.duration > e.latency) {
            if (n) t.duration > n.latency ? (n.entries = [t], n.latency = t.duration) : t.duration === n.latency && t.startTime === n.entries[0].startTime && n.entries.push(t);else {
              var r = {
                id: t.interactionId,
                latency: t.duration,
                entries: [t]
              };
              O.set(r.id, r), B.push(r);
            }
            B.sort(function (t, e) {
              return e.latency - t.latency;
            }), B.length > 10 && B.splice(10).forEach(function (t) {
              return O.delete(t.id);
            });
          }
        }
      },
      N = function (t) {
        var e = self.requestIdleCallback || self.setTimeout,
          n = -1;
        return t = v(t), "hidden" === document.visibilityState ? t() : (n = e(t), p(t)), n;
      },
      W = [200, 500],
      z = function (t, e) {
        "PerformanceEventTiming" in self && "interactionId" in PerformanceEventTiming.prototype && (e = e || {}, b(function () {
          var n;
          P();
          var r,
            i = f("INP"),
            a = function (t) {
              N(function () {
                t.forEach(H);
                var e = j();
                e && e.latency !== i.value && (i.value = e.latency, i.entries = e.entries, r());
              });
            },
            o = d("event", a, {
              durationThreshold: null !== (n = e.durationThreshold) && void 0 !== n ? n : 40
            });
          r = l(t, i, W, e.reportAllChanges), o && (o.observe({
            type: "first-input",
            buffered: !0
          }), p(function () {
            a(o.takeRecords()), r(!0);
          }), u(function () {
            R = F(), B.length = 0, O.clear(), i = f("INP"), r = l(t, i, W, e.reportAllChanges);
          }));
        }));
      },
      U = [],
      V = [],
      _ = 0,
      G = new WeakMap(),
      J = new Map(),
      K = -1,
      Q = function (t) {
        U = U.concat(t), X();
      },
      X = function () {
        K < 0 && (K = N(Y));
      },
      Y = function () {
        J.size > 10 && J.forEach(function (t, e) {
          O.has(e) || J.delete(e);
        });
        var t = B.map(function (t) {
            return G.get(t.entries[0]);
          }),
          e = V.length - 50;
        V = V.filter(function (n, r) {
          return r >= e || t.includes(n);
        });
        for (var n = new Set(), r = 0; r < V.length; r++) {
          var i = V[r];
          nt(i.startTime, i.processingEnd).forEach(function (t) {
            n.add(t);
          });
        }
        var a = U.length - 1 - 50;
        U = U.filter(function (t, e) {
          return t.startTime > _ && e > a || n.has(t);
        }), K = -1;
      };
    q.push(function (t) {
      t.interactionId && t.target && !J.has(t.interactionId) && J.set(t.interactionId, t.target);
    }, function (t) {
      var e,
        n = t.startTime + t.duration;
      _ = Math.max(_, t.processingEnd);
      for (var r = V.length - 1; r >= 0; r--) {
        var i = V[r];
        if (Math.abs(n - i.renderTime) <= 8) {
          (e = i).startTime = Math.min(t.startTime, e.startTime), e.processingStart = Math.min(t.processingStart, e.processingStart), e.processingEnd = Math.max(t.processingEnd, e.processingEnd), e.entries.push(t);
          break;
        }
      }
      e || (e = {
        startTime: t.startTime,
        processingStart: t.processingStart,
        processingEnd: t.processingEnd,
        renderTime: n,
        entries: [t]
      }, V.push(e)), (t.interactionId || "first-input" === t.entryType) && G.set(t, e), X();
    });
    var Z,
      $,
      tt,
      et,
      nt = function (t, e) {
        for (var n, r = [], i = 0; n = U[i]; i++) if (!(n.startTime + n.duration < t)) {
          if (n.startTime > e) break;
          r.push(n);
        }
        return r;
      },
      rt = function (t, n) {
        e || (e = d("long-animation-frame", Q)), z(function (e) {
          var n = function (t) {
            var e = t.entries[0],
              n = G.get(e),
              i = e.processingStart,
              o = n.processingEnd,
              c = n.entries.sort(function (t, e) {
                return t.processingStart - e.processingStart;
              }),
              u = nt(e.startTime, o),
              s = t.entries.find(function (t) {
                return t.target;
              }),
              f = s && s.target || J.get(e.interactionId),
              d = [e.startTime + e.duration, o].concat(u.map(function (t) {
                return t.startTime + t.duration;
              })),
              l = Math.max.apply(Math, d),
              m = {
                interactionTarget: a(f),
                interactionTargetElement: f,
                interactionType: e.name.startsWith("key") ? "keyboard" : "pointer",
                interactionTime: e.startTime,
                nextPaintTime: l,
                processedEventEntries: c,
                longAnimationFrameEntries: u,
                inputDelay: i - e.startTime,
                processingDuration: o - i,
                presentationDelay: Math.max(l - o, 0),
                loadState: r(e.startTime)
              };
            return Object.assign(t, {
              attribution: m
            });
          }(e);
          t(n);
        }, n);
      },
      it = [2500, 4e3],
      at = {},
      ot = function (t, e) {
        !function (t, e) {
          e = e || {}, b(function () {
            var n,
              r = S(),
              i = f("LCP"),
              a = function (t) {
                e.reportAllChanges || (t = t.slice(-1)), t.forEach(function (t) {
                  t.startTime < r.firstHiddenTime && (i.value = Math.max(t.startTime - s(), 0), i.entries = [t], n());
                });
              },
              o = d("largest-contentful-paint", a);
            if (o) {
              n = l(t, i, it, e.reportAllChanges);
              var c = v(function () {
                at[i.id] || (a(o.takeRecords()), o.disconnect(), at[i.id] = !0, n(!0));
              });
              ["keydown", "click"].forEach(function (t) {
                addEventListener(t, function () {
                  return N(c);
                }, !0);
              }), p(c), u(function (r) {
                i = f("LCP"), n = l(t, i, it, e.reportAllChanges), m(function () {
                  i.value = performance.now() - r.timeStamp, at[i.id] = !0, n(!0);
                });
              });
            }
          });
        }(function (e) {
          var r = function (t) {
            var e = {
              timeToFirstByte: 0,
              resourceLoadDelay: 0,
              resourceLoadDuration: 0,
              elementRenderDelay: t.value
            };
            if (t.entries.length) {
              var r = n();
              if (r) {
                var i = r.activationStart || 0,
                  o = t.entries[t.entries.length - 1],
                  c = o.url && performance.getEntriesByType("resource").filter(function (t) {
                    return t.name === o.url;
                  })[0],
                  u = Math.max(0, r.responseStart - i),
                  s = Math.max(u, c ? (c.requestStart || c.startTime) - i : 0),
                  f = Math.max(s, c ? c.responseEnd - i : 0),
                  d = Math.max(f, o.startTime - i);
                e = {
                  element: a(o.element),
                  timeToFirstByte: u,
                  resourceLoadDelay: s - u,
                  resourceLoadDuration: f - s,
                  elementRenderDelay: d - f,
                  navigationEntry: r,
                  lcpEntry: o
                }, o.url && (e.url = o.url), c && (e.lcpResourceEntry = c);
              }
            }
            return Object.assign(t, {
              attribution: e
            });
          }(e);
          t(r);
        }, e);
      },
      ct = [800, 1800],
      ut = function t(e) {
        document.prerendering ? b(function () {
          return t(e);
        }) : "complete" !== document.readyState ? addEventListener("load", function () {
          return t(e);
        }, !0) : setTimeout(e, 0);
      },
      st = function (t, e) {
        e = e || {};
        var r = f("TTFB"),
          i = l(t, r, ct, e.reportAllChanges);
        ut(function () {
          var a = n();
          a && (r.value = Math.max(a.responseStart - s(), 0), r.entries = [a], i(!0), u(function () {
            r = f("TTFB", 0), (i = l(t, r, ct, e.reportAllChanges))(!0);
          }));
        });
      },
      ft = function (t, e) {
        st(function (e) {
          var n = function (t) {
            var e = {
              waitingDuration: 0,
              cacheDuration: 0,
              dnsDuration: 0,
              connectionDuration: 0,
              requestDuration: 0
            };
            if (t.entries.length) {
              var n = t.entries[0],
                r = n.activationStart || 0,
                i = Math.max((n.workerStart || n.fetchStart) - r, 0),
                a = Math.max(n.domainLookupStart - r, 0),
                o = Math.max(n.connectStart - r, 0),
                c = Math.max(n.connectEnd - r, 0);
              e = {
                waitingDuration: i,
                cacheDuration: a - i,
                dnsDuration: o - a,
                connectionDuration: c - o,
                requestDuration: t.value - c,
                navigationEntry: n
              };
            }
            return Object.assign(t, {
              attribution: e
            });
          }(e);
          t(n);
        }, e);
      },
      dt = {
        passive: !0,
        capture: !0
      },
      lt = new Date(),
      mt = function (t, e) {
        Z || (Z = e, $ = t, tt = new Date(), gt(removeEventListener), pt());
      },
      pt = function () {
        if ($ >= 0 && $ < tt - lt) {
          var t = {
            entryType: "first-input",
            name: Z.type,
            target: Z.target,
            cancelable: Z.cancelable,
            startTime: Z.timeStamp,
            processingStart: Z.timeStamp + $
          };
          et.forEach(function (e) {
            e(t);
          }), et = [];
        }
      },
      vt = function (t) {
        if (t.cancelable) {
          var e = (t.timeStamp > 1e12 ? new Date() : performance.now()) - t.timeStamp;
          "pointerdown" == t.type ? function (t, e) {
            var n = function () {
                mt(t, e), i();
              },
              r = function () {
                i();
              },
              i = function () {
                removeEventListener("pointerup", n, dt), removeEventListener("pointercancel", r, dt);
              };
            addEventListener("pointerup", n, dt), addEventListener("pointercancel", r, dt);
          }(e, t) : mt(e, t);
        }
      },
      gt = function (t) {
        ["mousedown", "keydown", "touchstart", "pointerdown"].forEach(function (e) {
          return t(e, vt, dt);
        });
      },
      ht = [100, 300],
      Tt = function (t, e) {
        e = e || {}, b(function () {
          var n,
            r = S(),
            i = f("FID"),
            a = function (t) {
              t.startTime < r.firstHiddenTime && (i.value = t.processingStart - t.startTime, i.entries.push(t), n(!0));
            },
            o = function (t) {
              t.forEach(a);
            },
            c = d("first-input", o);
          n = l(t, i, ht, e.reportAllChanges), c && (p(v(function () {
            o(c.takeRecords()), c.disconnect();
          })), u(function () {
            var r;
            i = f("FID"), n = l(t, i, ht, e.reportAllChanges), et = [], $ = -1, Z = null, gt(addEventListener), r = a, et.push(r), pt();
          }));
        });
      },
      yt = function (t, e) {
        Tt(function (e) {
          var n = function (t) {
            var e = t.entries[0],
              n = {
                eventTarget: a(e.target),
                eventType: e.name,
                eventTime: e.startTime,
                eventEntry: e,
                loadState: r(e.startTime)
              };
            return Object.assign(t, {
              attribution: n
            });
          }(e);
          t(n);
        }, e);
      };

    // To avoid importing InstrumentationAbstract from:
    // import { InstrumentationAbstract } from '@opentelemetry/instrumentation/build/src/instrumentation';
    // When this is exposed we can import from there.
    class InstrumentationAbstract {
      constructor(instrumentationName, instrumentationVersion, config = {}) {
        this.instrumentationName = instrumentationName;
        this.instrumentationVersion = instrumentationVersion;
        /* Api to wrap instrumented method */
        // eslint-disable-next-line @typescript-eslint/unbound-method
        this._wrap = shimmer_1.wrap;
        /* Api to unwrap instrumented methods */
        // eslint-disable-next-line @typescript-eslint/unbound-method
        this._unwrap = shimmer_1.unwrap;
        /* Api to mass wrap instrumented method */
        // eslint-disable-next-line @typescript-eslint/unbound-method
        this._massWrap = shimmer_1.massWrap;
        /* Api to mass unwrap instrumented methods */
        // eslint-disable-next-line @typescript-eslint/unbound-method
        this._massUnwrap = shimmer_1.massUnwrap;
        this._config = Object.assign({
          enabled: true
        }, config);
        this._diag = diag.createComponentLogger({
          namespace: instrumentationName
        });
        this._tracer = trace.getTracer(instrumentationName, instrumentationVersion);
        this._meter = metrics.getMeter(instrumentationName, instrumentationVersion);
        this._updateMetricInstruments();
      }
      /* Returns meter */
      get meter() {
        return this._meter;
      }
      /**
       * Sets MeterProvider to this plugin
       * @param meterProvider
       */
      setMeterProvider(meterProvider) {
        this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
        this._updateMetricInstruments();
      }
      /**
       * Sets the new metric instruments with the current Meter.
       */
      _updateMetricInstruments() {
        return;
      }
      /* Returns InstrumentationConfig */
      getConfig() {
        return this._config;
      }
      /**
       * Sets InstrumentationConfig to this plugin
       * @param InstrumentationConfig
       */
      setConfig(config = {}) {
        this._config = Object.assign({}, config);
      }
      /**
       * Sets TraceProvider to this plugin
       * @param tracerProvider
       */
      setTracerProvider(tracerProvider) {
        this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
      }
      /* Returns tracer */
      get tracer() {
        return this._tracer;
      }
    }
    /**
     * Web vitals auto-instrumentation, sends spans automatically for CLS, LCP, INP, FCP, FID, TTFB.
     * Defaults to sending spans for CLS, LCP, INP, FCP and TTFB.
     * @param config The {@link WebVitalsInstrumentationConfig }
     */
    class WebVitalsInstrumentation extends InstrumentationAbstract {
      constructor({
        enabled = true,
        vitalsToTrack = ['CLS', 'LCP', 'INP'],
        lcp,
        cls,
        inp,
        fid,
        fcp,
        ttfb
      } = {}) {
        const config = {
          enabled,
          vitalsToTrack,
          lcp,
          cls,
          inp,
          fid,
          fcp,
          ttfb
        };
        super('@honeycombio/instrumentation-web-vitals', VERSION, config);
        this.onReportCLS = (cls, applyCustomAttributes) => {
          if (!this.isEnabled()) return;
          const {
            name,
            attribution
          } = cls;
          const {
            largestShiftTarget,
            largestShiftTime,
            largestShiftValue,
            loadState,
            largestShiftEntry
          } = attribution;
          const attrPrefix = this.getAttrPrefix(name);
          const span = this.tracer.startSpan(name);
          span.setAttributes(Object.assign(Object.assign({}, this.getSharedAttributes(cls)), {
            [`${attrPrefix}.largest_shift_target`]: largestShiftTarget,
            [`${attrPrefix}.element`]: largestShiftTarget,
            [`${attrPrefix}.largest_shift_time`]: largestShiftTime,
            [`${attrPrefix}.largest_shift_value`]: largestShiftValue,
            [`${attrPrefix}.load_state`]: loadState,
            [`${attrPrefix}.had_recent_input`]: largestShiftEntry === null || largestShiftEntry === void 0 ? void 0 : largestShiftEntry.hadRecentInput
          }));
          if (applyCustomAttributes) {
            applyCustomAttributes(cls, span);
          }
          span.end();
        };
        this.onReportLCP = (lcp, applyCustomAttributes) => {
          if (!this.isEnabled()) return;
          const {
            name,
            attribution
          } = lcp;
          const {
            element,
            url,
            timeToFirstByte,
            resourceLoadDelay,
            resourceLoadDuration,
            elementRenderDelay
          } = attribution;
          const attrPrefix = this.getAttrPrefix(name);
          const span = this.tracer.startSpan(name);
          span.setAttributes(Object.assign(Object.assign({}, this.getSharedAttributes(lcp)), {
            [`${attrPrefix}.element`]: element,
            [`${attrPrefix}.url`]: url,
            [`${attrPrefix}.time_to_first_byte`]: timeToFirstByte,
            [`${attrPrefix}.resource_load_delay`]: resourceLoadDelay,
            [`${attrPrefix}.resource_load_duration`]: resourceLoadDuration,
            [`${attrPrefix}.element_render_delay`]: elementRenderDelay,
            // This will be deprecated in a future version
            [`${attrPrefix}.resource_load_time`]: resourceLoadDuration
          }));
          if (applyCustomAttributes) {
            applyCustomAttributes(lcp, span);
          }
          span.end();
        };
        this.onReportINP = (inp, applyCustomAttributes, includeTimingsAsSpans = false) => {
          if (!this.isEnabled()) return;
          const {
            name,
            attribution
          } = inp;
          const {
            inputDelay,
            interactionTarget,
            interactionTime,
            interactionType,
            loadState,
            nextPaintTime,
            presentationDelay,
            processingDuration,
            longAnimationFrameEntries: _loafEntries
          } = attribution;
          const longAnimationFrameEntries = _loafEntries;
          const attrPrefix = this.getAttrPrefix(name);
          const inpDuration = inputDelay + processingDuration + presentationDelay;
          this.tracer.startActiveSpan(name, {
            startTime: interactionTime
          }, inpSpan => {
            const inpAttributes = Object.assign(Object.assign({}, this.getSharedAttributes(inp)), {
              [`${attrPrefix}.input_delay`]: inputDelay,
              [`${attrPrefix}.interaction_target`]: interactionTarget,
              [`${attrPrefix}.interaction_time`]: interactionTime,
              [`${attrPrefix}.interaction_type`]: interactionType,
              [`${attrPrefix}.load_state`]: loadState,
              [`${attrPrefix}.next_paint_time`]: nextPaintTime,
              [`${attrPrefix}.presentation_delay`]: presentationDelay,
              [`${attrPrefix}.processing_duration`]: processingDuration,
              [`${attrPrefix}.duration`]: inpDuration,
              // These will be deprecated in a future version
              [`${attrPrefix}.element`]: interactionTarget,
              [`${attrPrefix}.event_type`]: interactionType
            });
            inpSpan.setAttributes(inpAttributes);
            if (applyCustomAttributes) {
              applyCustomAttributes(inp, inpSpan);
            }
            if (includeTimingsAsSpans) {
              longAnimationFrameEntries.forEach(perfEntry => {
                this.processPerformanceLongAnimationFrameTimingSpans(attrPrefix, perfEntry);
              });
            }
            inpSpan.end(interactionTime + inpDuration);
          });
        };
        this.onReportFCP = (fcp, applyCustomAttributes) => {
          if (!this.isEnabled()) return;
          const {
            name,
            attribution
          } = fcp;
          const {
            timeToFirstByte,
            firstByteToFCP,
            loadState
          } = attribution;
          const attrPrefix = this.getAttrPrefix(name);
          const span = this.tracer.startSpan(name);
          span.setAttributes(Object.assign(Object.assign({}, this.getSharedAttributes(fcp)), {
            [`${attrPrefix}.time_to_first_byte`]: timeToFirstByte,
            [`${attrPrefix}.time_since_first_byte`]: firstByteToFCP,
            [`${attrPrefix}.load_state`]: loadState
          }));
          if (applyCustomAttributes) {
            applyCustomAttributes(fcp, span);
          }
          span.end();
        };
        /**
         *  @deprecated this will be removed in the next major version, use INP instead.
         */
        this.onReportFID = (fid, applyCustomAttributes) => {
          if (!this.isEnabled()) return;
          const {
            name,
            attribution
          } = fid;
          const {
            eventTarget,
            eventType,
            loadState
          } = attribution;
          const attrPrefix = this.getAttrPrefix(name);
          const span = this.tracer.startSpan(name);
          span.setAttributes(Object.assign(Object.assign({}, this.getSharedAttributes(fid)), {
            [`${attrPrefix}.element`]: eventTarget,
            [`${attrPrefix}.event_type`]: eventType,
            [`${attrPrefix}.load_state`]: loadState
          }));
          if (applyCustomAttributes) {
            applyCustomAttributes(fid, span);
          }
          span.end();
        };
        this.onReportTTFB = (ttfb, applyCustomAttributes) => {
          if (!this.isEnabled()) return;
          const {
            name,
            attribution
          } = ttfb;
          const {
            cacheDuration,
            connectionDuration,
            dnsDuration,
            requestDuration,
            waitingDuration
          } = attribution;
          const attrPrefix = this.getAttrPrefix(name);
          const attributes = Object.assign(Object.assign({}, this.getSharedAttributes(ttfb)), {
            [`${attrPrefix}.waiting_duration`]: waitingDuration,
            [`${attrPrefix}.dns_duration`]: dnsDuration,
            [`${attrPrefix}.connection_duration`]: connectionDuration,
            [`${attrPrefix}.request_duration`]: requestDuration,
            [`${attrPrefix}.cache_duration`]: cacheDuration,
            // These will be deprecated ina future version
            [`${attrPrefix}.waiting_time`]: waitingDuration,
            [`${attrPrefix}.dns_time`]: dnsDuration,
            [`${attrPrefix}.connection_time`]: connectionDuration,
            [`${attrPrefix}.request_time`]: requestDuration
          });
          const span = this.tracer.startSpan(name);
          span.setAttributes(attributes);
          if (applyCustomAttributes) {
            applyCustomAttributes(ttfb, span);
          }
          span.end();
        };
        this.vitalsToTrack = [...vitalsToTrack];
        this.lcpOpts = lcp;
        this.clsOpts = cls;
        this.inpOpts = inp;
        this.fidOpts = fid;
        this.fcpOpts = fcp;
        this.ttfbOpts = ttfb;
        this._isEnabled = enabled;
        this._setupWebVitalsCallbacks();
      }
      init() {}
      _setupWebVitalsCallbacks() {
        if (this.vitalsToTrack.includes('CLS')) {
          D(vital => {
            var _a;
            this.onReportCLS(vital, (_a = this.clsOpts) === null || _a === void 0 ? void 0 : _a.applyCustomAttributes);
          }, this.clsOpts);
        }
        if (this.vitalsToTrack.includes('LCP')) {
          ot(vital => {
            var _a;
            this.onReportLCP(vital, (_a = this.lcpOpts) === null || _a === void 0 ? void 0 : _a.applyCustomAttributes);
          }, this.lcpOpts);
        }
        if (this.vitalsToTrack.includes('INP')) {
          rt(vital => {
            var _a, _b;
            this.onReportINP(vital, (_a = this.inpOpts) === null || _a === void 0 ? void 0 : _a.applyCustomAttributes, (_b = this.inpOpts) === null || _b === void 0 ? void 0 : _b.includeTimingsAsSpans);
          }, this.inpOpts);
        }
        if (this.vitalsToTrack.includes('FID')) {
          yt(vital => {
            var _a;
            this.onReportFID(vital, (_a = this.fidOpts) === null || _a === void 0 ? void 0 : _a.applyCustomAttributes);
          }, this.fidOpts);
        }
        if (this.vitalsToTrack.includes('TTFB')) {
          ft(vital => {
            var _a;
            this.onReportTTFB(vital, (_a = this.ttfbOpts) === null || _a === void 0 ? void 0 : _a.applyCustomAttributes);
          }, this.ttfbOpts);
        }
        if (this.vitalsToTrack.includes('FCP')) {
          w(vital => {
            var _a;
            this.onReportFCP(vital, (_a = this.fcpOpts) === null || _a === void 0 ? void 0 : _a.applyCustomAttributes);
          }, this.fcpOpts);
        }
      }
      getAttrPrefix(name) {
        return name.toLowerCase();
      }
      getSharedAttributes(vital) {
        const {
          name,
          id,
          delta,
          rating,
          value,
          navigationType
        } = vital;
        const attrPrefix = this.getAttrPrefix(name);
        return {
          [`${attrPrefix}.id`]: id,
          [`${attrPrefix}.delta`]: delta,
          [`${attrPrefix}.value`]: value,
          [`${attrPrefix}.rating`]: rating,
          [`${attrPrefix}.navigation_type`]: navigationType
        };
      }
      getAttributesForPerformanceLongAnimationFrameTiming(prefix, perfEntry) {
        const loafAttributes = {
          [`${prefix}.duration`]: perfEntry.duration,
          [`${prefix}.entryType`]: perfEntry.entryType,
          [`${prefix}.name`]: perfEntry.name,
          [`${prefix}.renderStart`]: perfEntry.renderStart,
          [`${prefix}.startTime`]: perfEntry.startTime
        };
        return loafAttributes;
      }
      getAttributesForPerformanceScriptTiming(prefix, scriptPerfEntry) {
        const scriptAttributes = {
          [`${prefix}.entry_type`]: scriptPerfEntry.entryType,
          [`${prefix}.start_time`]: scriptPerfEntry.startTime,
          [`${prefix}.execution_start`]: scriptPerfEntry.executionStart,
          [`${prefix}.duration`]: scriptPerfEntry.duration,
          [`${prefix}.forced_style_and_layout_duration`]: scriptPerfEntry.forcedStyleAndLayoutDuration,
          [`${prefix}.invoker`]: scriptPerfEntry.invoker,
          [`${prefix}.pause_duration`]: scriptPerfEntry.pauseDuration,
          [`${prefix}.source_url`]: scriptPerfEntry.sourceURL,
          [`${prefix}.source_function_name`]: scriptPerfEntry.sourceFunctionName,
          [`${prefix}.source_char_position`]: scriptPerfEntry.sourceCharPosition,
          [`${prefix}.window_attribution`]: scriptPerfEntry.windowAttribution
        };
        return scriptAttributes;
      }
      processPerformanceLongAnimationFrameTimingSpans(parentPrefix, perfEntry) {
        if (!perfEntry) return;
        const prefix = `${parentPrefix}.timing`;
        const loafAttributes = this.getAttributesForPerformanceLongAnimationFrameTiming(prefix, perfEntry);
        this.tracer.startActiveSpan(perfEntry.name, {
          startTime: perfEntry.startTime
        }, span => {
          span.setAttributes(loafAttributes);
          this.processPerformanceScriptTimingSpans(prefix, perfEntry.scripts);
          span.end(perfEntry.startTime + perfEntry.duration);
        });
      }
      processPerformanceScriptTimingSpans(parentPrefix, perfScriptEntries) {
        if (!perfScriptEntries) return;
        if (!(perfScriptEntries === null || perfScriptEntries === void 0 ? void 0 : perfScriptEntries.length)) return;
        const prefix = `${parentPrefix}.script`;
        perfScriptEntries.map(scriptPerfEntry => {
          this.tracer.startActiveSpan(scriptPerfEntry.name, {
            startTime: scriptPerfEntry.startTime
          }, span => {
            const scriptAttributes = this.getAttributesForPerformanceScriptTiming(prefix, scriptPerfEntry);
            span.setAttributes(scriptAttributes);
            span.end(scriptPerfEntry.startTime + scriptPerfEntry.duration);
          });
        });
      }
      disable() {
        if (!this.isEnabled()) {
          this._diag.debug(`Instrumentation already disabled`);
          return;
        }
        this._isEnabled = false;
        this._diag.debug(`Instrumentation  disabled`);
      }
      enable() {
        if (this.isEnabled()) {
          this._diag.debug(`Instrumentation already enabled`);
          return;
        }
        this._isEnabled = true;
        this._diag.debug(`Instrumentation  enabled`);
        this._diag.debug(`Sending spans for ${this.vitalsToTrack.join(',')}`);
      }
      isEnabled() {
        return this._isEnabled;
      }
    }

    /**
     * Global errors auto-instrumentation, sends spans automatically for exceptions that reach the window.
     * @param config The {@link GlobalErrorsInstrumentationConfig}
     */
    class GlobalErrorsInstrumentation extends InstrumentationAbstract {
      constructor({
        enabled = true
      } = {}) {
        const config = {
          enabled
        };
        super('@honeycombio/instrumentation-global-errors', VERSION, config);
        this.onError = event => {
          const error = 'reason' in event ? event.reason : event.error;
          const message = error === null || error === void 0 ? void 0 : error.message;
          const type = error === null || error === void 0 ? void 0 : error.name;
          const attributes = {
            [SEMATTRS_EXCEPTION_TYPE]: type,
            [SEMATTRS_EXCEPTION_MESSAGE]: message,
            [SEMATTRS_EXCEPTION_STACKTRACE]: error === null || error === void 0 ? void 0 : error.stack
          };
          // otel spec requires at minimum these two
          if (!message || !type) return;
          const errorSpan = this.tracer.startSpan('exception', {
            attributes
          }, context.active());
          errorSpan.setStatus({
            code: SpanStatusCode.ERROR,
            message
          });
          errorSpan.end();
        };
        if (enabled) {
          this.enable();
        }
        this._isEnabled = enabled;
      }
      init() {}
      disable() {
        if (!this.isEnabled()) {
          this._diag.debug(`Instrumentation already disabled`);
          return;
        }
        this._isEnabled = false;
        window.removeEventListener('error', this.onError);
        window.removeEventListener('unhandledrejection', this.onError);
        this._diag.debug(`Instrumentation  disabled`);
      }
      enable() {
        if (this.isEnabled()) {
          this._diag.debug(`Instrumentation already enabled`);
          return;
        }
        this._isEnabled = true;
        window.addEventListener('error', this.onError);
        window.addEventListener('unhandledrejection', this.onError);
        this._diag.debug(`Instrumentation  enabled`);
      }
      isEnabled() {
        return this._isEnabled;
      }
    }

    class HoneycombWebSDK extends WebSDK {
      constructor(options) {
        var _a, _b;
        const instrumentations = [...((options === null || options === void 0 ? void 0 : options.instrumentations) || [])];
        // Automatically include web vitals instrumentation unless explicitly set to false
        if (((_a = options === null || options === void 0 ? void 0 : options.webVitalsInstrumentationConfig) === null || _a === void 0 ? void 0 : _a.enabled) !== false) {
          instrumentations.push(new WebVitalsInstrumentation(options === null || options === void 0 ? void 0 : options.webVitalsInstrumentationConfig));
        }
        // Automatically include global errors instrumentation unless explicitly set to false
        if (((_b = options === null || options === void 0 ? void 0 : options.globalErrorsInstrumentationConfig) === null || _b === void 0 ? void 0 : _b.enabled) !== false) {
          instrumentations.push(new GlobalErrorsInstrumentation(options === null || options === void 0 ? void 0 : options.globalErrorsInstrumentationConfig));
        }
        super(Object.assign(Object.assign({}, options), {
          instrumentations,
          resource: mergeResources([configureBrowserAttributesResource(), configureEntryPageResource(options === null || options === void 0 ? void 0 : options.entryPageAttributes), options === null || options === void 0 ? void 0 : options.resource, options === null || options === void 0 ? void 0 : options.resourceAttributes, configureHoneycombResource()]),
          sampler: configureDeterministicSampler(options),
          // Exporter is configured through the span processor because
          // the base SDK does not allow having both a spanProcessor and a
          // traceExporter configured at the same time.
          spanProcessor: configureSpanProcessors(options)
        }));
        validateOptionsWarnings(options);
        if (options === null || options === void 0 ? void 0 : options.debug) {
          configureDebug(options);
        }
      }
    }

    exports.HoneycombWebSDK = HoneycombWebSDK;
    exports.InstrumentationAbstract = InstrumentationAbstract;
    exports.WebSDK = WebSDK;
    exports.WebVitalsInstrumentation = WebVitalsInstrumentation;

    return exports;

})({});
